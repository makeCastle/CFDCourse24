@page notes Краткое содержание лекций

# 1. Введение (02.09)
Общее описание инфраструктуры проекта для работы по курсу лекций.

# 2. Уравнение Пуассона (09.09)

Решение одномерной задачи Пуассона с граничными условиями первого рода методом конечных разностей.
Понятие о точности аппроксимации сеточной схемы.

## Постановка задачи
Рассматривается одномерное дифференциальное уравнение вида
\f{equation}{
    \label{eq:poisson1d}
    -\ddfrq{u}{x} = f(x)
\f}
в области \f$x\in[a,b]\f$ с граничными условиями первого рода
\f{equation}{
	\label{eq:poisson1d_bc}
	\begin{cases}
        u(a)=u_a,\\[5pt]
        u(b)=u_b.\\
	\end{cases}
\f}
Необходимо:
- Запрограммировать расчётную схему для численного решения этого уравнения методом конечных разностей
  на сетке с постоянным шагом,
- С помощью вычислительных экспериментов подтвердить порядок аппроксимации расчётной схемы.

## Метод решения

### Нахождение численного решения {#poisson1d_fdm}

В области решения \f$[a,b]\f$ введём равномерную сетку из \f$N\f$ ячеек.
Шаг сетки будет равен \f$h=(b-a)/N\f$.
Узлы сетки запишем в виде сеточного вектора \f$\{x_i\}\f$ длины \f$N+1\f$, где \f$i=\overline{0,N}\f$.
Определим сеточный вектор \f$\{u_i\}\f$ неизвестных, элементы которого определяют значение искомого численного решения в \f$i\f$-ом узле сетки. 

Разностная схема второго порядка для уравнения \f(\eqref{eq:poisson1d}\f) имеет вид
\f{equation}{
    \label{eq:poisson1d_fdm}
    \frac{-u_{i-1} + 2u_{i} - u_{i+1}}{h^2} = f_i, \qquad i=\overline{1,N-1}.
\f}
Здесь \f$\{f_i\}\f$ -- известный сеточный вектор, определяемый через известную
аналитическую функцию \f$f(x)\f$ в правой части уравнения \f(\eqref{eq:poisson1d}\f) как
\f{equation}{
    \label{eq:poisson1d_fdm2}
    f_i = f(x_i).
\f}

Аппроксимация граничных условий \f(\eqref{eq:poisson1d_bc}\f) первого рода даёт дополнительные 
сеточные уравнения для граничных узлов
\f{equation}{
    \label{eq:poisson1d_fdm_bc}
    \begin{array}{ll}
        u_0 = u_a,\\
        u_N = u_b
    \end{array}
\f}

Линейные уравнения \f(\eqref{eq:poisson1d_fdm}, \eqref{eq:poisson1d_fdm_bc}\f)
составляют систему вида

\f{equation*}{
    \sum_{j=0}^{N} A_{ij}\,u_j = b_i, \qquad i=\overline{0,N}
\f}
с матричными коэффициентами
\f{equation}{
    \label{eq:poisson1d_fdm_lhs}
    A_{ij} = \begin{cases}
        1,      &\quad i=0, \, j=0; \\
        2/h^2,  &\quad i=\overline{1,N-1}, \, j=i;\\
        -1/h^2, &\quad i=\overline{1,N-1}, \, j=i-1;\\
        -1/h^2, &\quad i=\overline{1,N-1}, \, j=i+1;\\
        1,      &\quad i=N, \, j=N; \\
        0,      &\quad {\text иначе}.
    \end{cases}
\f}
и правой частью
\f{equation}{
    \label{eq:poisson1d_fdm_rhs}
    b_i = \begin{cases}
        u_a,   &\quad i=0;\\
        u_b,   &\quad i=N;\\
        f_i,   &\quad i=\overline{1,N-1}.
    \end{cases}
\f}
Искомый вектор находится путём решения этой системы.

### Практическое определения порядка аппроксимации

Порядок аппрокцимации показывает скорость
приближения численного решения к точному с уменьшением сетки.
Поэтому для подтверждения порядка необходимо
- Знать точное решение,
- Уметь вычислять функционал (норму, \f(||\cdot||\f)), характеризующий отклонение точного решения от численного,
- Сделать несколько расчётов на сетках с разной \f(N\f)  и заполнить таблицу \f(||\{u_i - u^e(x_i)\}||(N)\f),
- На основе этой таблицы построить график в логарифмических осях и по углу наклона кривой сделать вывод о порядке аппроксимации.

Выберем произвольную функцию \f$u^e\f$ (достаточно сильно изменяющуюся на целевом отрезке \f$[a,b]\f$).

Далее путём прямого вычисления определим параметры задачи \f$f\f$, \f$u_a\f$, \f$u_b\f$ такие,
для которых функция \f$u^e\f$ является точным решением задачи \f(\eqref{eq:poisson1d}\f), \f(\eqref{eq:poisson1d_bc}\f).

Зададимся числом разбиений \f$N\f$ и решим задачу для выбранным параметров.
В результате определим сеточный вектор численного решения \f$\{u_i\}\f$.

В качестве нормы выберем стандартное отклонение. В интегральном виде для многомерной функции \f$y(\vec x)\f$
в области \f$\vec x\in D\f$ оно имеет вид
\f{equation*}{
    ||y(\vec x)||_2 = \sqrt{\frac{1}{|D|}\int_{D} y(\vec x)^2 \, d\vec x}.
\f}
Упрощая до одномерного случая
\f{equation*}{
    ||y(x)||_2 = \sqrt{\frac{1}{b-a}\int_{a}^{b} y(x)^2 \, dx}.
\f}

Вычислим этот интеграл численно на введённой ранее равномерной сетке \f$\{x_i\}\f$:
\f{equation*}{
    ||\{y_i\}||_2 = \sqrt{\frac{1}{b-a}\sum_{i=0}^{N} w_i y_i^2},
\f}
где \f$\{w_i\}\f$ -- вес (или "площадь влияния") \f$i\f$-ого узла:
\f{equation*}{
    w_i = \begin{cases}
        h/2, &\quad i=0, N;\\
        h, &\quad i=\overline{1,N-1},
    \end{cases}
\f}
такая что
\f{equation*}{
    \sum_{i=0}^{N} w_i = b-a.
\f}

Окончательно среднеквадратичная норма отклонения численного решения от точного запишется в виде
\f{equation}{
    \label{eq:poisson1d_fdm_norm}
    ||\{u_i - u^e(x_i)\}||_2 = \sqrt{\frac{1}{b-a}\sum_{i=0}^{N} w_i \left(u_i - u^e_i\right)^2}.
\f}

## Программная реализация {#test_poisson1}
\dontinclude{lineno} poisson_solve_test.cpp

Тестовая программа для решения одномерного уравнения Пуассона 
реализована в фале poisson_solve_test.cpp.

В качестве аналитической тестовой функции  используется
\f{equation*}{
    u^e = \sin(10 x^2)
\f}
на отрезке \f$x\in[0,1]\f$.

### Функция верхнего уровня
объявлена как
\skip TEST_CASE("Poisson 1D solver", "[poisson1]"){
\until TEST_CASE
В программе в цикле по набору разбиений \c n_cells
\skip for (size_t n_cells
\until for (size_t n_cells
создаётся решатель для тестовой задачи, использующий заданное число ячеек
\skip worker
\until worker
вычисляется среднеквадратичная норма отклонения численного решения от точного
\skip n2
\until n2
полученное численное решение (вместе с точным) сохраняется в vtk файле "poisson1_ncells={10,20,...}.vtk"
\skip save_vtk
\until save_vtk
а полученная норма печатается в консоль напротив количества ячеек
\skip cout
\until cout

В результате работы программы в консоли должна отобразиться таблица вида
@code
--- cfd24_test [poisson1] ---
10 0.179124
20 0.0407822
50 0.00634718
100 0.00158055
200 0.000394747
500 6.31421e-05
1000 1.57849e-05
@endcode
где первый столбец -- это количество ячеек, а второй -- полученная для этого количества ячеек норма.
Нарисовав график этой таблицы в логарифмических осях подтвердим второй порядок аппроксимации.

\image html poisson1_appr.png width=800

Открыв один из cохранённых в процессе работы файлов vtk poisson1_ncells={}.vtk в паравью
можно посмотреть полученные графики. В файле представлены как точное "exact", так и численное решение "numerical".
Инструкции о настройке отображения одномерных графиков смотри \ref paraview-1d "здесь".

\image html poisson1_graph.png width=600

### Детали реализации
Основная работа по решению задачи проводится в классе \c TestPoisson1Worker.

В его конструкторе происходит инициализация сетки (приватного поля класса) на отрезке \f([0, 1]\f) с заданным разбиением \c n_cells:
\dontinclude{lineno} poisson_solve_test.cpp
\skip TestPoisson1Worker(
\until TestPoisson1Worker(

В методе \c solve() производится чиленное решения задачи и вычисления нормы.
Для этого последовательно
1. Строится матрица левой части и вектор правой части определяющей системы уравнений.
   Матрицы хранятся в разреженном формате CSR, удобном для последовательного чтения.
2. Вызывается решатель СЛАУ. Решение записывается в приватное поле класса \c u.
3. Вызывается функция вычисления нормы.

\skip double solve()
\until }

Функции нижнего уровня (используемые в методе \c solve):
- Сборка левой части СЛАУ. Реализует формулу \f(\eqref{eq:poisson1d_fdm_lhs}\f).
  Для заполнения матрицы используется формат cfd::LodMatrix, удобный для непоследовательной записи, который в конце конвертируется CSR.
  \skip approximate_lhs(
  \until return
  \until }

- Сборка правой части СЛАУ. Реализует формулу \f(\eqref{eq:poisson1d_fdm_rhs}\f).
  \skip approximate_rhs(
  \until return
  \until }

- Вычисление нормы. Реализует формулу \f(\eqref{eq:poisson1d_fdm_norm}\f).
  \skip double compute_norm2
  \until return
  \until }

# 3. Двухслойные схемы для нестационарных уравнений (16.09)

## Определение

Рассмотрим дифференциальное уравнение вида

\f{equation}{
    \label{eq:nonstat_common}
    \dfr{u}{t} + Lu = f,
\f}
где \f(L\f) -- произвольный пространственный дифференциальный оператор.
При использовании двухслойной схемы аппроксимации производная по времени записывается в
виде конечной разности с шагом \f(\tau\f), которая может приближать производную
в одном из трёх моментов времени:

\f{equation}{
    \label{eq:nonstat_dt_appr}
    \begin{array}{lll}
        \dfrac{u(t+\tau) - u(t)}{\tau} = 
            & \quad \left.\ddfr{u}{t}\right|_{t}
            & + o(\tau)
            & -\text{ разность вперёд};\\[5pt]
        \phantom{a}
            & \quad \left.\ddfr{u}{t}\right|_{t+\tau}
            & + o(\tau)
            & -\text{ разность назад};\\[5pt]
        \phantom{a}
            & \quad \left.\ddfr{u}{t}\right|_{t+\frac{\tau}{2}}
            & + o(\tau^2)
            & -\text{ симметричная разность.}
    \end{array}
\f}

Момент времени \f(t\f) будем называть текущим временн<strong>ы</strong>м слоем,
момент \f(t + \tau\f) -- следующим,
а момент \f(t+\tau/2\f) -- промежуточным.
Считается, что
значение функции на текущий момент времени \f(u(t)\f) известно, а
значение на следующий момент \f(u(t+\tau)\f) подлежит определению.

### Явная схема

При использовании разности назад уравнение \f(\eqref{eq:nonstat_common}\f)
в полудискретизованном (то есть дискретизованном только по времени, но не по пространству) виде
запишется как
\f{equation*}{
    \frac{u(x, t+\tau) - u(x)}{\tau} + L u(x, t) = f(x, t)
\f}
или, после переноса всех известных слагаемых вправо
\f{equation}{
    \label{eq:nonstat_explicit}
    u(x, t+\tau) = \left(E - \tau L\right) u(x, t) + \tau f(x, t).
\f}
Здесь \f(E\f) -- единичный оператор.
Схема \f(\eqref{eq:nonstat_explicit}\f) называется явной схемой
и имеет первый порядок точности.

### Неявная схема

Выбрав разность назад из выражения \f(\eqref{eq:nonstat_dt_appr}\f)
полудискретизованная схема для уравнения \f(\eqref{eq:nonstat_common}\f) примет вид
\f{equation*}{
    \frac{u(x, t+\tau) - u(x)}{\tau} + L u(x, t+\tau) = f(x, t+\tau).
\f}
В результате преобразования получим неявную схему первого порядка точности
\f{equation}{
    \label{eq:nonstat_implicit}
    \left(E+\tau L\right) u(x, t+\tau) = u(x, t) + \tau f(x, t + \tau).
\f}

### Схема Кранка--Николсон

Подставим симметричную разность из \f(\eqref{eq:nonstat_dt_appr}\f)
в уравнение \f(\eqref{eq:nonstat_common}\f). Формально получим
\f{equation*}{
    \frac{u(x, t+\tau) - u(x)}{\tau} + L u(x, t+\frac{\tau}{2}) = f(x, t+\frac{\tau}{2}).
\f}

Для определения выражения функций на промежуточном временном слое
распишем значение \f$u\f$ на текущем и следующем слоях в ряд Тейлора
относительно значения на момент \f$t+\tau/2\f$:
\f{align*}{
    u\left(t\right)      &= u\left(t+\frac{\tau}{2}\right) - \left.\frac{\tau}{2}\dfr{u}{t}\right|_{t+\frac{\tau}{2}} + o(\tau^2)\\
    u\left(t+\tau\right) &= u\left(t+\frac{\tau}{2}\right) + \left.\frac{\tau}{2}\dfr{u}{t}\right|_{t+\frac{\tau}{2}} + o(\tau^2)
\f}
Взяв полусумму этих выражений получим аппроксимацию функции на промежуточном слое:
\f{equation}{
    \label{eq:nonstat_cn_appr}
    u\left(x, t + \frac{\tau}{2}\right) = \frac12u\left(x, t\right) + \frac12u\left(x, t+\tau\right) + o(\tau^2)
\f}
Аналогичная запись справедлива и для свободного члена \f$f\f$.
Если оператор \f(L\f) -- нестационарный или нелининый, то аппроксимацию \f(\eqref{eq:nonstat_cn_appr}\f)
следует записывать для всего выражения \f(Lu\f):
\f{equation*}{
    \left(Lu\right)_{t+\frac{\tau}{2}} = \frac12\left(Lu\right)_{t} + \frac12\left(Lu\right)_{t+\tau} + o(\tau^2)
\f}


С учётом \f(\eqref{eq:nonstat_cn_appr}\f) симметричная разностная схема
запишется как
\f{equation*}{
    \frac{u(x, t+\tau) - u(x)}{\tau} + \frac12L u(x, t) + \frac12 L u(x, t + \tau) = \frac12 f(x, t) + \frac12 f(x, t+\tau)
\f}
или
\f{equation}{
    \label{eq:nonstat_cn}
    \left(E+\frac{\tau}{2} L\right) u(x, t+\tau) = \left(E - \frac{\tau}{2} L\right) u(x, t) + \frac{\tau}{2} \left(f(x, t) + f(x, t + \tau)\right).
\f}
Такая схема называется схемой Кранка--Николсон и имеет второй порядок аппроксимации по времени.

В случае, если оператор \f(L\f) зависит от времени, то
в левой части схемы \f(\eqref{eq:nonstat_cn}\f) его нужно
брать на следующем временном слое, а в правой -- на текущем.

### Обобщённая двухслойная схема

Выражения
\f(\eqref{eq:nonstat_explicit}\f),
\f(\eqref{eq:nonstat_implicit}\f),
\f(\eqref{eq:nonstat_cn}\f)
можно записать в обобщённой форме
\f{equation}{
    \label{eq:nonstat_theta}
    \left(E+\theta\tau L\right) u(x, t+\tau) = \left(E + \left(\theta - 1\right)\tau L\right) u(x, t) + \left(1 - \theta\right) f(x, t) + \theta f(x, t + \tau).
\f}
Коэффициент \f(\theta\f) -- степень неявности схемы:
- \f(\theta = 0\f) -- явная схема \f(\eqref{eq:nonstat_explicit}\f),
- \f(\theta = 1\f) -- полностью неявная схема \f(\eqref{eq:nonstat_implicit}\f),
- \f(\theta = 1/2\f) -- схема Кранка--Николсон \f(\eqref{eq:nonstat_cn}\f).

Отметим, что только при \f(\theta = 1/2\f) схема \f(\eqref{eq:nonstat_theta}\f) имеет второй порядок точности по времени.
Для других значений (в том числе промежуточных) схема будет иметь ошибку первого порядка \f(o(\tau)\f).

## Дискретизация по времени как итерационный процесс

### Двухслойный итерационный процесс

Простой двухслойный итерационный процесс определяется как
\f{equation}{
    \label{eq:nonstat_common_iter}
    u^{n+1} = A u^{n} + b,
\f}
где \f(n\f) -- индекс итерационного слоя,
\f(A\f) -- оператор преобразования,
\f(b\f) -- свободный член.

Определение значения функции на следующий момент времени \f(u(t+\tau)\f) 
по двухслойной схеме \f(\eqref{eq:nonstat_theta}\f) можно представить как простой итерационный процесс \f(\eqref{eq:nonstat_common_iter}\f), где
\f{align*}{
    A &= \left(E + \theta \tau L \right)^{-1} \left(E + (\theta - 1) \tau L \right), \\\\
    b &= \left(E + \theta \tau L \right)^{-1} \left( \theta f\left(x, t + \tau\right) + \left(1 - \theta\right) f\left(x, t\right) \right).
\f}

Итерационный процесс называется сходящимся, если
\f{equation*}{
    \lim_{n=\infty} \left\lVert u^{n+1} - u^{n} \right\rVert = 0.
\f}

### Устойчивость итерационного процесса {#ScalarIter}

Рассмотрим два простых итерационных процесса,
имеющих на нулевом слое значение \f(u^0 = 1\f):
\f{align*}{
    {\rm (I)}:\quad  &u^{n+1} = 2 u^{n} - 1, \\
    {\rm (II)} :\quad  &u^{n+1} = 0.5 u^{n} + 0.5.
\f}
Оба этих процесса при выбранном начальном приближении, очевидно, сходятся.
На каждой итерации справделиво \f(u^n = 1\f).
Возмутим начальное условие: пусть
\f{equation*}{
    u^0 = 1 + \eps,
\f}
и проведём итерации.
\f{equation*}{
    \begin{array}{c|c|c}
        & {\rm (I)}  &  {\rm (II)} \\ 
        \hline
        u^1 & 1 + 2\eps & 1 + \dfrac{\eps}{2} \\ 
        \hline
        u^2 & 1 + 4\eps & 1 + \dfrac{\eps}{4} \\ 
        \hline
        u^3 & 1 + 8\eps & 1 + \dfrac{\eps}{8} \\ 
        \hline
        ... & & \\
        \hline
        u^\infty & \infty & 1 \\ 
    \end{array}
\f}

Видно, что процесс \f(\rm (I)\f) теряет сходимость и стремится к бесконечности,
в то время, как процесс \f(\rm (II)\f) сохраняет свои свойства.

Свойство итерационных процессов уменьшать малые возмущения называется устойчивостью.
В примере выше процесс \f(\rm (I)\f) является неустойчивым, а процесс \f(\rm (II)\f) -- устойчивым.

Нетрудно видеть, что для рассматриваемого скалярного итерационного процесса,
условие устойчивости запишется в виде \f(|A| \leq 1\f).

### Источники возмущений

На практике возникновение возмущений в решениях неизбежно:
они могут быть следствием ошибок дискретизации функций и операторов,
погрешностей решения СЛАУ, ошибок при проведении арифметических
операций на числах с плавающей точкой и т.д.
Поэтому любой итерационный процесс, используемый для решений
математических задач, должен быть устойчив.

Возникновение непреднамеренных ошибок вследствии компьютерного округления можно проиллюстрировать на примере
программы, в которой рассматривается сходящийся для любого начального условия, но неустойчивый итерационный процесс
\f{equation*}{
    u^{n+1} = 10 u^{n} - 9 u^{0}.
\f}
\code{cpp}
double u0 = 0.625;
double u = u0;
for (int i=0; i<1000; ++i){
    u = 10*u - 9*u0;
}
std::cout << u << std::endl;
\endcode

Если начальное значение может быть точно представлено в
числах с плавающей точкой (путём конечной суммы степеней двойки),
то арифметическая ошибка не возникает.
Так, представленный выше код на выходе печатает ожидаемое \f(u=0.625\f).
Потому что начальное приближение может быть разложено как \f(u^0 = 2^{-1} + 2^{-3}\f).

Однако, если заменить начальное приближение на любое число,
которое не может быть записано точно во floating-point формате,
то процесс быстро уходит в бесконечность.
Например, для \f(u^0 = 0.626\f) бесконечные (непредставимые в машинном формате) значения
появляются на 324-ой итерации,
а при переключении на работу в числах одинарной точности `float` -- уже на 46-ой.

## Методы исследования устойчивости расчётных схем

### Матричный метод

Итерационные процессы, возникающие при численном решении
дифференциальных уравнений сеточными методами, имеют матричную природу.
То есть оператор преобразования \f(A\f) в выражении \f(\eqref{eq:nonstat_common_iter}\f) -- это матрица,
а функции \f(u\f) и \f(b\f) -- векторы-столбцы.

Как было показано выше, условием устойчивости скалярного итерационного процесса является неравенство \f(|A| \leq 1\f).
Аналогом этого условия для матричного процесса является ограничение на спектральный радиус \f(S(A)\f):
\f{equation}{
    \label{eq:nonstat_spectral_radius}
    S(A) = \max_j{ | \lambda_j | } \leq 1,
\f}
где \f(\lambda_j\f) -- собственные числа матрицы \f(A\f).

Для некоторых видов матриц, возникающих при аппроксимации простейших дифференциальных уравнений,
собственные числа известны.

#### Явная схема для нестационарного уравнения диффузии {#NonstatExpDiff}

Например, рассмотрим одномерное нестационарное уравнение диффузии с граничными условиями первого рода
\f{align*}{
    &\dfr{u}{t} = k\dfrq{u}{x},\\[5pt]
    &u(x, 0) = u_0(x),\\[5pt]
    &u(x_a, t) = u_a,\\[5pt]
    &u(x_b, t) = u_b.\\
\f}
Используем явную дискретизацию по времени и аппроксимацию второго порядка по пространству.
Тогда разностная схема запишется в виде:
\f{equation}{
    \label{eq:nonstat_explicit_diff}
    \hat u_i = u_i + \gamma (u_{i-1} - 2 u_i + u_{i+1}), \quad i = \overline{1, N-1},
\f}
где введено обозначение для значения функции на следующем временном слое \f(\hat u = u(t+\tau)\f) и \f(\gamma = \tau k / h^2 \f).
В матричном виде схема имеет вид
\f{equation*}{
    \hat u = A u, \quad
    A = \left(
        \begin{array}{cccccc}
            1      & 0          &           &            &           &        \\
            \gamma & 1-2\gamma  & \gamma    &            &           &        \\
                   & \gamma     & 1-2\gamma & \gamma     &           &        \\
                   &            & \ddots    & \ddots     & \ddots    &        \\
                   &            &           & \gamma     & 1-2\gamma & \gamma \\ 
                   &            &           &            & 0         & 1      
        \end{array}
    \right).
\f}
Первая и последняя строки этой матрицы -- следствие учёта граничных условий первого рода.

Собственные числа для полученной трёхдиагональной матрицы преобразования в правой части имеют вид
\f{equation*}{
    \lambda_j = 1 - 4\gamma\sin^2\left(\frac{j\pi}{2 N}\right), \quad j = \overline{1, N-1}
\f}
Тогда, исходя из выражения \f(\eqref{eq:nonstat_spectral_radius}\f), запишем условие устойчивости
для явной схемы \f(\eqref{eq:nonstat_explicit_diff}\f)
\f{equation*}{
    \gamma \leq \frac12
\f}

#### Неявная схема для нестационарного уравнения диффузии {#NonstatImpDiff}

Аналогично, рассмотрим неявную схему
\f{equation}{
    \label{eq:nonstat_implicit_diff}
    \hat u_i - \gamma (\hat u_{i-1} - 2 \hat u_i + \hat u_{i+1}) = u_i, \quad i = \overline{1, N-1},
\f}
В матричном виде
\f{equation*}{
    \hat u = A^{-1} u, \quad
    A = \left(
        \begin{array}{cccccc}
            1      & 0          &           &            &           &        \\
            -\gamma& 1+2\gamma  &-\gamma    &            &           &        \\
                   &-\gamma     & 1+2\gamma &-\gamma     &           &        \\
                   &            & \ddots    & \ddots     & \ddots    &        \\
                   &            &           &-\gamma     & 1+2\gamma &-\gamma \\ 
                   &            &           &            & 0         & 1      
        \end{array}
    \right).
\f}

Собственные числа такой матрицы имеют вид
\f{equation*}{
    \lambda_j = 1 + 4\gamma\sin^2\left(\frac{j\pi}{2 N}\right), \quad j = \overline{1, N-1}
\f}
Поскольку в правой части итерационного процесса используется матрица, обратная к \f(A\f),
а собственные числа обратных матриц равны \f(1/\lambda_j\f), то условие устойчивости
примет вид
\f{equation*}{
    \lambda_j \geq 1.
\f}
Очевидно, что оно выполняется всегда. Поэтому неявная схема \f(\eqref{eq:nonstat_implicit_diff}\f) безусловно устойчива.

### Метод дискретных возмущений

Метод дискретных возмущений заключается
в использовании в качестве начального приближения
нулевого вектора, с возмущением \f(\eps\f)
в одном из узлов:
\f{equation*}{
    u^0 = \left(
        \begin{array}{c}
            0\\
            \vdots\\
            0\\
            \eps\\
            0\\
            \vdots\\
            0
        \end{array}
        \right)
\f}
и дальнейшем анализом
распространения этого возмущения с прохождением
по временным слоям.
Во многом этот метод аналогичен тому алгоритму,
по которому мы иллюстрировали устойчивость
\ref ScalarIter "простейшего скалярного итерационного процесса".

#### Явная схема против потока для уравнения переноса {#NonstatExpTran}

Для иллюстрации рассмотрим одномерное уравнение переноса
\f{equation}{
    \label{eq:nonstat_transport}
    \dfr{u}{t} + V\dfr{u}{x} = 0
\f}
и явную противопоточную схему для него (при условии \f(V > 0\f))
\f{equation}{
    \label{eq:nonstat_explicit_transport}
    \hat u_i = u_i - C \left(u_i - u_{i-1}\right),
\f}
где число Куранта определено как \f(C = \tau V /h \f).

Пусть \f(u_i = \eps\f). Тогда
\f{align*}{
    & \hat u_i = (1 - C) \eps & \hence & \; 0 \leq C \leq 2,  \\[5pt]
    & \hat u_{i+1} = C \eps   & \hence & \; -1 \leq C \leq 1.
\f}
Поскольку \f(C\f) по определению больше нуля, то условием устойчивости для схемы \f(\eqref{eq:nonstat_explicit_transport}\f)
будет выражение
\f{equation*}{
    C \leq 1.
\f}

### Метод Неймана

Запишем обратное преобразование Фурье для функции u(x):
\f{equation*}{
    u(x) = \int v(\kappa) e^{\imi \kappa x} \, d\kappa,
\f}
\f(\kappa\f) -- волновое число, \f(\imi\f) -- мнимая единица, \f(v(\kappa)\f) -- Фурье образ исходной функции.

Зададим такое начальное возмущение, которое имеет единичную амплитуду 
на одной частоте, соответствующей волновому числу \f(\kappa_0\f):
\f{equation*}{
    v(\kappa) = \delta(\kappa - \kappa_0),
\f}
\f(\delta(x)\f) -- функция Дирака.
Кроме того, учтём, что \f(x_i = ih\f).
Тогда выбранное начальное возмущение на одной выбранной частоте, взятое в \f(i\f)-ом узле, примет вид
\f{equation}{
    \label{eq:nonstat_neumann_decomp}
    u_i = e^{\imi i \theta}, \quad \theta = \kappa_0 h
\f}
На следующем временном шаге это возмущение примет вид:
\f{equation}{
    \label{eq:nonstat_neumann_decomp_hat}
    \hat u_i = G e^{\imi i \theta}.
\f}
\f(G\f) -- коэффициент усиления. Он показывает во сколько раз
увеличилась амплитуда выбранного возмущения за один шаг по времени.
Для того, чтобы все возмущения затухали, необходимо
\f{equation*}{
    |G| \leq 1, \quad \forall \theta
\f}

#### Неявная противопотоковая схема для уравнения переноса {#NonstatImpConv}

Для примера анализа устойчивости методом Неймана опять рассмотрим задачу \f(\eqref{eq:nonstat_transport}\f),
но на этот раз рассмотрим чисто неявную аппроксимацию
\f{equation}{
    \label{eq:nonstat_implicit_transport}
    \hat u_i + C \left(\hat u_i - \hat u_{i-1}\right) = u_i.
\f}

Подставим \f(\eqref{eq:nonstat_neumann_decomp}\f), \f(\eqref{eq:nonstat_neumann_decomp_hat}\f)
\f{equation*}{
    G e(i) + C \left(G e(i) - G e(i-1)\right)= e(i). 
\f}
где для краткости введено обозначение
\f{equation*}{
    e(i) = e^{\imi \theta i}.
\f}
Поделим на \f(e(i)\f) с использованием свойств этой степенной функции. Тогда

\f{align*}{
    & G + C G \left(1 - e(-1)\right)= 1 \quad \hence \\[10pt]
    & G = (1 + C (1 - e(-1)))^{-1}.
\f}
По определению комплексной экспоненты имеем
\f{equation*}{
    e(-1) = \cos \theta - \imi \sin\theta.
\f}
Требуется показать, что \f(|G| \leq 1\f). Отсюда
\f{align*}{
    & |1 + C (1 - \cos\theta + \imi\sin\theta)|  \geq 1 \quad \hence \\[10pt]
    & |1 + C (1 - \cos\theta) + C\imi\sin\theta)|^2 \geq 1 \quad \hence \\[10pt]
    & 1 + C^2(1-\cos\theta)^2 + 2C(1-\cos\theta) + C^2\sin^2\theta \geq 1 \quad \hence \\[10pt]
    & C^2(1-\cos\theta) + 2C + C^2(1+\cos\theta) \geq 0 \quad \hence \\[10pt]
    & C^2 + 2C \geq 0.
\f}
По определению число Куранта больше 0, поэтому последнее выражение выполняется всегда.
Отсюда следует вывод, что неявная разностная схема вида \f(\eqref{eq:nonstat_implicit_transport}\f)
безусловно устойчива.

#### Противопотоковая схема Кранка-Николсон для уравнения переноса {#NonstatCNConv}

Для того же самого уравнения \f(\eqref{eq:nonstat_transport}\f)
рассмотрим схему Кранка-Николсон \f(\eqref{eq:nonstat_cn_appr}\f):
\f{equation}{
    \label{eq:nonstat_cn_transport}
    \hat u_i + \frac{C}{2} \left(\hat u_i - \hat u_{i-1}\right) = u_i - \frac{C}{2} \left(u_i - u_{i-1}\right).
\f}
Так же
подставим \f(\eqref{eq:nonstat_neumann_decomp}\f), \f(\eqref{eq:nonstat_neumann_decomp_hat}\f)
и поделим на \f(e(i)\f):
\f{align*}{
    & G + \frac{C G}{2} \left(1 - e(-1)\right) = 1 - \frac{C}{2} \left(1 - e(-1)\right) \quad \hence \\[10pt]
    & G = \frac{1 - p}{1 + p}, \quad p = \frac{C}{2} \left(1 - e(-1)\right).
\f}
Для выполнения условия устойчивости \f(|G| \leq 1\f), необходимо
\f{align*}{
    & |1-p|^2 \leq |1+p|^2 \quad \hence \\[10pt]
    & (1 - \Re(p))^2 + \Im(p)^2 \leq (1+\Re(p))^2 + \Im(p)^2  \quad \hence \\[10pt]
    & \Re(p) \geq 0
\f}
Здесь \f(\Re(p)\f), \f(\Im(p)\f) -- дейсвительная и мнимая часть комплексного числа.

Поскольку число Куранта больше нуля, то и действительная часть выражения \f(p\f) неотрицательная для любого \f(\theta\f).
\f{equation*}{
    \Re(p) = \frac{C}{2} \left(1 - \cos\theta\right) \geq 0.
\f}
Получаем, что схема видеа \f(\eqref{eq:nonstat_cn_transport}\f) безусловно устойчива.

#### Явная схема для уравнения нестационарной конвекции-диффузии {#NonstatExpConvDiff}

Рассмотрим уравнение конвекции-диффузии
\f{equation}{
    \label{eq:nonstat_convdiff}
    \dfr{u}{t} + V\dfr{u}{x} = k\dfrq{u}{x}
\f}

Сначала напишем чисто явную схему второго порядка по пространству:
\f{equation}{
    \label{eq:nonstat_convdiff_explicit}
    \frac{\hat u_i - u_i}{\tau} + V\frac{u_{i+1} - u_{i-1}}{2h} = k\frac{u_{i+1} - 2 u_{i} + u_{i-1}}{h^2}
\f}
Введем число Куранта \f(C = V \tau/h\f) и параметр \f(\gamma = k \tau / h^2\f). Тогда

\f{equation*}{
    \hat u_i = \left(\gamma - \frac{C}{2}\right) u_{i+1} + \left(\gamma + \frac{C}{2}\right) u_{i-1} + (1 - 2\gamma) u_i.
\f}
Далее подставим \f(\eqref{eq:nonstat_neumann_decomp}\f), \f(\eqref{eq:nonstat_neumann_decomp_hat}\f)
\f{equation*}{
    G e(i) = \left(\gamma - \frac{C}{2}\right) e(i+1) + \left(\gamma + \frac{C}{2}\right) e(i-1) + (1 - 2\gamma) e(i).
\f}
Поделим на \f(e(i)\f) с использованием свойств этой степенной функции. Тогда
\f{equation*}{
    G = \gamma(e(1) + e(-1)) - \frac {C}{2} (e(1) - e(-1)) + (1 - 2\gamma)
\f}
По определению комплексной экспоненты имеем
\f{align*}{
    e(1) &= \cos \theta + \imi \sin\theta,\\
    e(-1) &= \cos \theta - \imi \sin\theta,
\f}
Отсюда
\f{equation*}{
    G = 2\gamma\cos\theta - \imi {C} \sin\theta + (1 - 2\gamma)
\f}
Запишем квадрат модуля комплексного числа \f(G\f):
\f{align*}{
    |G|^2 = & \left(1 - 2\gamma(1-\cos\theta)\right)^2 + C^2 \sin^2\theta =\\
            & 1 + 4 \gamma^2(1-\cos\theta)^2 - 4\gamma(1-\cos\theta) + C^2 (1 - \cos^2\theta).
\f}

Требование \f(|G| \leq 1\f) эквивалентно \f(|G|^2 \leq 1\f), или
\f{align*}{
    &1 + 4 \gamma^2(1-\cos\theta)^2 - 4\gamma(1-\cos\theta) + C^2 (1 - \cos^2\theta) \leq 1 \quad \hence \\[5pt]
    &4 \gamma^2(1-\cos\theta)^2 - 4\gamma(1-\cos\theta) + C^2 (1 - \cos^2\theta) \leq 0 \quad \hence \\[5pt]
    &4 \gamma^2(1-\cos\theta) - 4\gamma + C^2 (1 + \cos\theta) \leq 0 \quad \hence \\[5pt]
    &(C^2 - 4 \gamma^2) \cos\theta +4\gamma^2 - 4\gamma + C^2 \leq 0
\f}

Поскольку неравенство должно выполняться для всех \f(\theta\f),
а полученное выражение линейно зависит от \f(\cos\theta\f), то будет достаточно рассмотреть два экстремальных значения косинуса,
из которых окончательно запишем два условия устойчивости для явной дискретизации уравнения конвекции-диффузии вида \f(\eqref{eq:nonstat_convdiff_explicit}\f):
\f{equation}{
    \label{eq:nonstat_convdiff_explicit_cond}
    \begin{array}{lcl}
        \cos\theta = 1  & \hence & C \leq \sqrt{2\gamma}, \\
        \cos\theta = -1 & \hence & \gamma \leq 1/2.
    \end{array}
\f}

Обычно вместо первого из условий \f(\eqref{eq:nonstat_convdiff_explicit_cond}\f) применяют
более жёсткое (в случае \f(2\gamma < 1\f)) условие
\f{equation*}{
    C \leq 2\gamma,
\f}
которое с учётом определений сводится к условию на шаг по пространству, формулируемому в терминах сеточного числа Рейнольдса \f(\Ren_c\f):
\f{equation*}{
    \frac{V h}{k} \equiv \Ren_c \leq 2.
\f}

#### Неявная схема для уравнения нестационарной конвекции-диффузии {#NonstatImpConvDiff}

Аналогичным образом рассмотрим неявную диффузии схему для уравнения \f(\eqref{eq:nonstat_convdiff}\f) вида
\f{equation}{
    \label{eq:nonstat_convdiff_semi_implicit}
    \frac{ \hat u_i - u_i}{\tau} + V\frac{ u_{i+1} - u_{i-1}}{2h} = k\frac{\hat u_{i+1} - 2 \hat u_{i} + \hat u_{i-1}}{h^2}
\f}

Подставляя представление для возмущения с волновым числом \f(\theta\f), получим
\f{equation*}{
    G = \frac{1 - \imi C \sin\theta}{1 - 2\gamma(\cos\theta - 1)}
\f}

Для устойчивости необходимо
\f{align*}{
    & |1 - \imi C \sin\theta|^2 \leq |1 - 2\gamma(\cos\theta - 1)|^2 \quad \hence \\[10pt]
    & 1 + C^2\sin^2\theta \leq 1 + 4\gamma^2(1 - \cos\theta)^2 + 4\gamma(1-\cos\theta) \quad \hence \\[10pt]
    & C^2(1 + \cos\theta) \leq 4\gamma^2(1 - \cos\theta) + 4\gamma \quad \hence \\[10pt]
    & \cos\theta(C^2 + 4\gamma^2) + C^2 - 4\gamma - 4\gamma^2 \leq 0
\f}
Наибольшего значения выражение слева достигает при \f(\theta = 0\f). Тогда единственное условие устойчивости 
примет вид
\f{equation*}{
    C \leq \sqrt{2\gamma}.
\f}

### Общие рекомендации к выбору устойчивых расчётных схем
Теоретический анализ условий устойчивости возможен
лишь для простейших уравнений с постоянными шагами дискретизации.
В практических приложениях, имеющих дело, как правило,
с неструктурированными сетками и сложными нелинейными системами уравнений,
параметры устойчивого счёта приходится определять эмпирически.
Однако, такой теоретический анализ позволяет выделить принципы, которыми
следует руководствоваться для построения устойчивых схем.

  1. <U>Неявные схемы более устойчивы, чем явные</U>.
     - Это можно видеть, сравнив результаты анализа
       для безусловно устойчивой \ref NonstatImpDiff "неявной схемы" для уравнения диффузного переноса и
       для условно устойчивой \ref NonstatExpDiff "явной схемы".

     - Для уравнения переноса с разностью против потока
       \ref NonstatExpTran "явная" схема условно устойчива, в то время как
       \ref NonstatImpConv "неявная" -- устойчива безусловно.

     - Даже если только часть схемы неявная, это повышает устойчивость.
       Так, \ref NonstatExpConvDiff "явная" схема для уравнения конвекции-диффузии
       имеет два условия устойчивости, в то время как
       схема, \ref NonstatImpConvDiff "неявная по диффузии" -- только одно.

     - Аналогично, \ref NonstatExpTran "явная" схема против потока для
       уравнения переноса условно устойчива,
       а \ref NonstatCNConv "схема Кранка-Николсон" для того же уравнения устойчива при любых параметрах.

  2. <U>Конвективное слагаемое провоцирует неусточивость, а диффузионное -- напротив, добавляет устойчивость</U>.
     - Так, схемы с центральными разностями для уравнения конвекции-диффузии (и \ref NonstatExpConvDiff "явная", и \ref NonstatImpConvDiff "полунеявная"),
       условно устойчивы. Явная схема с центральными разностями для чистого уравнения переноса всегда неустойчива.
       В последнем можно убедится, подставив \f(k=0\f) в условия устойчивости для уравнений конвекции-диффузии.


## Программная реализация схемы для уравнения переноса 

### Постановка задачи
Рассматриваются три схемы по времени для противопотоковой аппроксимации уравнения переноса \f(\eqref{eq:nonstat_transport}\f): 
- явная схема \f(\eqref{eq:nonstat_explicit_transport}\f) (тест называется `[transport1-explicit]`),
- неявная схема \f(\eqref{eq:nonstat_implicit_transport}\f) (`[transport1-implicit]`),
- схема Кранка--Николсон \f(\eqref{eq:nonstat_cn_transport}\f) (`[tranport1-cn]`).

Уравнение решается на отрезке \f(x\in[0, 1]\f) с единичной скоростью \f(V = 1\f) 
на сетке из 1000 ячеек. Временные итерации продолжаются до момента времени \f(t = 0.5\f).

Начальным условием является функция вида
\f{equation*}{
    u(x, 0) = e^{-x^2/\sigma^2}, \quad \sigma = 0.1
\f}
Точное решение уравнения, с которого будут сниматься граничные условия и производится сравнения полученного численного решения,
запишется как
\f{equation*}{
    u(x, t) = u(x - t, 0) = e^{-(x-t)^2/\sigma^2}.
\f}

На каждом шаге по времени функция сохраняется в vtk-формате.
В конце выводится значение отклонения от точного решения на конечный момент времени.

В качестве цели решения обозначим построение решения и визуальное сравнение решений
при числе \f(C=0.9\f) по трём разным схемам.
А также построение графика сходимости отклонения точного решения
от численного при изменении числа Куранта и фиксированном шаге по пространству
(то есть сходимость при уменьшении шага по времени).

Программы реализованы в файле `transport_solve_test.cpp`.

### Функция верхнего уровня
\dontinclude{lineno} transport_solve_test.cpp

Для всех трёх программ функция верхнего уровня имеет один и тот же вид.
Рассмотрим на примере первой из них:
\skip "[transport1-explicit]"
\until TEST_CASE

Вначале происходит установка параметров численной схемы:
- конечного момента времени
- скорости переноса
- длины расчётной области
- разбиения по пространству
- числа Куранта

\skip const double
\until Cu

Далее вычисляются используемые шаги:
- шаг по пространству (из длины области и разбиения),
- шаг по времени (из шага по пространству и числа Куранта)

\skip double h
\until double tau

Потом устанавливается рабочий класс, в котором будет производится решение
\skip TestTransport1WorkerExplicit worker(n_cells)
\until n_cells

Конструируется класс, используемый для связного сохранения
полей на разные моменты времени.
Этот класс создаёт файл `transport1-explicit.vtk.series`
со списком всех сохранённых полей и отнесёнными к ним моментами времени,
который можно впоследствии открыть в Paraview и использовать
функции анимации для воспроизведения поведения решения во времени.
\skip VtkUtils::TimeDependentWriter writer("transport1-explicit");
\until writer
Далее нужно в этот класс сохранить решение на начальный момент времени.
Для этого туда сначала добавляется запись о нулевом моменте времени
\skip out_filename
\until out_filename
В переменную `out_filename` записывается конкретное
имя vtk-файла, куда следует сохранить решение.
Уже это имя используется для сохранения решения на текущий (начальный) момент времени.
\skip out_filename
\until out_filename

Далее начинается цикл по времени,
продолжающийся до тех пор, пока внутреннее время решателя
не достигнет конечного
\skip while
\until while

Внутри вызывается функция решения, которая продвигает
внутреннее время решателя на \f(\tau\f), обновляет
актуальное состояние вектора решения
и возвращает текущую норму.
\skip norm
\until norm

Потом повторяется процедура сохранения
текущего состояния решателя
\skip out_filename
\until save_vtk

После завершения цикла в консоль печатается
установленное разбиение по времени и
полученное отклонение от точного решения
на конечный момент времени 
\skip cout
\until cout

### Расчётные функции

Три класса-решателя для трёх заявленных задач:
`TestTransport1WorkerExplicit`,
`TestTransport1WorkerImplicit`,
`TestTransport1WorkerCN`
наследуются от одного абстрактного класса
`ATestTransport1Worker`. В этом
абстрактном классе реализованы
все общие для всех решателей функции:
создание сетки, сохранение в vtk,
расчёт нормы, продвижение по времени.

Этот класс также хранит в себе параметры, полностью определяющие текущее состояние решения:
- расчётную сетку,
- шаг по времени (это параметр, производный от сетки, он сохранён в отдельное поле для удобства расчётов),
- вектор решения на текущий момент,
- текущее время.

Эти поля хранятся в `protected` секции, таким образом
все производные классы имеют к этим полям полный доступ.
\dontinclude{lineno} transport_solve_test.cpp
\skip protected:
\until _time

Функция решения, также реализована в абстрактном классе.
Она продвигает текущее время и вызывает
виртуальный метод `impl_step`, который
изменяет значение вектора решения, а в конце вызывает
функцию вычисления ошибки.
\dontinclude{lineno} transport_solve_test.cpp
\skip double step
\until }

Функция `impl_step` уже зависит от конкретной схемы и реализована в
производных классах

#### Явная схема

\dontinclude{lineno} transport_solve_test.cpp

Её решатель реализован в классе `TestTransport1WorkerExplicit`. Рабочая функция по порядку:
- копирует текущий вектор значений во вспомогательный вектор `u_old`.
  Этот шаг добавлен сюда для ясности. Вообще говоря, его можно было избежать.
- устанавливает граничное условие в левой точке
- далее в цикле по точкам реализует расчётную схему \f(\eqref{eq:nonstat_explicit_transport}\f).

\skip TestTransport1WorkerExplicit
\skip impl_step
\until }
\until }


#### Неявная схема
Её решатель реализован в классе `TestTransport1WorkerImplicit`.
Поскольку здесь для нахождения решения требуется решить СЛАУ, то
порядок действий включает в себя:
- формирование класса-решателя.
- формирование столбца свободных членов
- вызова функции решения СЛАУ для найденного столбца правой части. Ответ записывается
  во внутреннее поле класса `_u`

\skip TestTransport1WorkerImplicit
\skip impl_step
\until }

Для построения и инициализации решателя необходимо
собрать матрицу правой части системы уравнений \f(\eqref{eq:nonstat_implicit_transport}\f).
Матрица зависит от шага по времени (через число Куранта), при этом шаг по времени является
аргументом функции `build_solver`, которая приходит от пользователя решателя через аргумент функции `step()`.

Таким образом, в логике работы приложения, нам придётся пересобирать матрицу на каждой временной итерации.
При этом, почти всегда шаги по времени постоянны для временных слоёв. То есть одну и ту же операцию (сборку матрицы)
при одним и тех же аргументах (шаге по времени) придётся повторять. 

Поскольку сборка матрицы -- дорогая операция, то результат работы
функции `build_solver` мы кэшируем (сохраняем во внутреннее поле класса `_solver`).
С тем чтобы на следующем временном слое в случае, если шаг по времени не изменился (`_last_used_tau == tau`),
просто вернуть ответ, посчитанный ранее.
\skip build_solver
\until return
\until }

Сама сборка двухдиагональной матрицы происходит в функции `build_lhs`.
В первой и последней строке учитываются граничные условия, а строки, соответствующие внутренним узлам,
заполняются согласно схеме \f(\eqref{eq:nonstat_implicit_transport}\f)
\skip build_lhs
\until return
\until }

Сама сборка правой части СЛАУ происходит в функции `build_rhs`.
Согласно схеме \f(\eqref{eq:nonstat_implicit_transport}\f)
правый столбец равен значению функции на предыдущем временном слое.
В коде мы создаём столбец `rhs` как копию вектора `_u`.
А далее переписываем первый и последний элемент с тем, чтобы
учесть граничные условия.
\skip build_rhs
\until return
\until }

#### Схема Кранка-Николсон
Её решатель реализован в классе `TestTransport1WorkerCN`.

По аналогии с предыдущей программой, здесь требуется
решить СЛАУ, возникающую из схемы \f(\eqref{eq:nonstat_cn_transport}\f).
Таким образом, вся логика работы этого класса (включая кэширование решателя) повторяет логику
работы рассмотренного ранее класса для чисто неявной схемы `TestTransport1WorkerImplicit`.
Отличаются эти классы только реализацией функций построения матрицы и
правой части. Поэтому настоящий класс наследуется от `TestTransport1WorkerImplicit`
\skip TestTransport1WorkerCN
\until public

и переопределяет только функции 
сборки левой части \f(\eqref{eq:nonstat_cn_transport}\f) с учётом граничных условий
\skip build_lhs
\until return
\until }

и правой части \f(\eqref{eq:nonstat_cn_transport}\f) с учётом граничных условий
\skip build_rhs
\until return
\until }

### Анализ результатов работы

Сравнение полученных ответов (по явной и неявной схемам) с точным решением представлено на картинке ниже.
\image html transport1_solution.png width=1000

Чтобы получить такую картинку необходимо открыть в
Paraview сгенерированные в результате работы программ
выходные файлы `transport1_explicit.vtk.series` и `transport1_implicit.vtk.series`.
И далее проделать преобразования, описанные в пункте \ref paraview-1d.

Для построения графиков сходимости, необходимо преобразовать
написанные программы, запустив цикл по различным значениям числа Куранта
\code{cpp}
for (double Cu: { ... }){
    // solution
    std::cout << 1/tau << " " << norm << std::endl;
}
\endcode
и построить график полученной таблицы в логарифмических осях.
При задании диапазона изменений \f(C\f) следует учитывать, что явная схема устойчива только при \f(C \leq 1\f),
в то время как две другие схемы безусловно устойчивы.

Графики сходимости с уменьшением шага по времени
представлены ниже
\image html transport1_norms.png width=1000

Видно, что для явной схемы с уменьшением шага по времени
ответ отдаляется от точного, а для неявной -- наоборот, приближается.

Это объясняется тем, что в случае явной схемы
ошибки по времени и по пространству имеют разный знак
и (в случае их равенства) компенсируют друг друга.
А для неявной эти ошибки имеют одинаковый знак.

В пределе (с минимальным шагом по времени) все три схемы
сходятся к одной и той же ошибке (ошибке схемы по пространству).


# 4. Система Навье-Стокса. Схема SIMPLE (30.09)

## Постановка задачи

Будем рассматривать стационарную двумерную систему уравнений
Навье-Стокса для вязкой несжимаемой жидкости.
В безразмерном консервативном виде в декартовой системе координат она имеет вид

\f{align}{
    \label{eq:ns2d_u}
    & \dfr{u^2}{x} + \dfr{uv}{y} =
        -\dfr{p}{x}
        + \frac{1}{\Ren}\left(\dfrq{u}{x} + \dfrq{u}{y}\right),\\[5pt]
    \label{eq:ns2d_v}
    & \dfr{uv}{x} + \dfr{v^2}{y} =
        -\dfr{p}{y}
        + \frac{1}{\Ren}\left(\dfrq{v}{x} + \dfrq{v}{y}\right), \\[5pt]
    \label{eq:ns2d_div}
    &\dfr{u}{x} + \dfr{v}{y} = 0.
\f}

Неизвестными являются поля скорости: \f(u\f) -- в направлении оси \f(x\f),
 \f(v\f) -- в направлении оси \f(y\f), и давления \f(p\f).

Число Рейнольдса определено через характерную скорость \f(U\f), [м/c] и
характерный линейный размер \f(L\f), [м] как
\f{equation*}{
    \Ren = \frac{UL\rho}{\mu},
\f}
где \f(\rho\f), [кг/м\f(^3\f)] -- постоянная (вследствии несжимаемости) плотность жидкости, а
\f(\mu\f), [Па\f(\cdot\f)с] -- динамическая вязкость жидоксти.

Характерое значение для давление выпишется в виде:
\f(
    p^0 = \rho U^2
\f), [Па].

Для решения этой системы будем использовать метод конечных разностей
с аппроксимацией по пространству второго порядка и последовательное (раздельное) решение входящих в неё
уравнений.

Глядя на вид уранений \f(\eqref{eq:ns2d_u} - \eqref{eq:ns2d_div}\f)
можно выделить несколько проблем, которые необходимо решить
при построении расчётной схемы:
- нелинейность конвективного оператора в \f(\eqref{eq:ns2d_u}, \eqref{eq:ns2d_v}\f),
- отсутствие явного уравнения для определения давления,
- аппркосимация первых производных для давления и скорости со вторым порядком точности.

Для решения первой проблемы будем использовать итерационный процесс с линеаризацией -- то есть
записывать уравнение на итерационном слое используя значения неизвестных полей с прошлого слоя.
Вторую проблему будем решать с помощью алгоритма SIMPLE
связывания давления и скорости (Pressure-Velocity Coupling).
Решать третью проблему будем с помощью пространственной аппроксимации на разнесённой сетке (Staggered Grid).

## Расчётная схема

Стационарную задачу \f(\eqref{eq:ns2d_u}-\eqref{eq:ns2d_div}\f) будем решать
методом установления. Для этого в первые два уравнения введём фиктивную
производную по времени, которую распишем по неявной двухслойной схеме с шагом \f(\tau\f).
Тогда задача на одном итерационном слое примет вид

\f{align}{
    \label{eq:ns2d_semi_u}
    & \frac{\hat u - u}{\tau} + \dfr{u \hat u}{x} + \dfr{v \hat u}{y} =
        -\dfr{\hat p}{x}
        + \frac{1}{\Ren}\left(\dfrq{\hat u}{x} + \dfrq{\hat u}{y}\right),\\[5pt]
    \label{eq:ns2d_semi_v}
    & \frac{\hat v - v}{\tau} + \dfr{u\hat v}{x} + \dfr{v \hat v}{y} =
        -\dfr{\hat p}{y}
        + \frac{1}{\Ren}\left(\dfrq{\hat v}{x} + \dfrq{\hat v}{y}\right), \\[5pt]
    \label{eq:ns2d_semi_div}
    &\dfr{\hat u}{x} + \dfr{\hat v}{y} = 0.
\f}

При записи была произведена линеаризация конвективного слагаемого:
один из множителей в производной был отнесён на предыдущий
временной слой. В остальном схема неявная.

На временном слое значения \f(u, v, p\f)
известны, а \f(\hat u, \hat v, \hat p\f) подлежат определению.

Критерием выхода из итерационного процесса является пороговое условие на невязку,
вычисленную с использованием найденных на слое значений неизвестных:
\f{align}{
    \nonumber
    &r_u = \dfr{\hat u \hat u}{x} + \dfr{\hat u \hat v}{y}
        + \dfr{\hat p}{x}
        - \frac{1}{\Ren}\left(\dfrq{\hat u}{x} + \dfrq{\hat u}{y}\right),\\[5pt]
    \nonumber
    &r_v = \dfr{\hat u\hat v}{x} + \dfr{\hat v \hat v}{y}
        +\dfr{\hat p}{y}
        - \frac{1}{\Ren}\left(\dfrq{\hat v}{x} + \dfrq{\hat v}{y}\right), \\[5pt]
    \label{eq:ns2d_residual}
    &\max(\lVert r_u \rVert, \lVert r_v \rVert) < \eps.
\f}

## SIMPLE {#simple-algo}

Приведём алгоритм для явного выражения уравнения для давления из
уравнения неразрывности \f(\eqref{eq:ns2d_semi_div}\f).

Распишем искомые перенные в виде суммы 
\f{equation}{
    \label{eq:ns2d_decomp}
\begin{array}{l}
    \hat u = u^* + u',\\
    \hat v = v^* + v',\\
    \hat p = p + p'.
\end{array}
\f}

Пусть введённые выше поля \f(u^*\f), \f(v^*\f) удовлетворяют уравнениям
\f{align}{
    \label{eq:ns2d_ustar}
    &u^* + \tau\dfr{u u^*}{x} + \tau\dfr{v u^*}{y}
       - \frac{\tau}{\Ren}\left(\dfrq{u^*}{x} + \dfrq{u^*}{y}\right)
       = -\tau\dfr{p}{x} + u, \\[5pt]
    \label{eq:ns2d_vstar}
    &v^* + \tau\dfr{u v^*}{x} + \tau\dfr{v v^*}{y}
       - \frac{\tau}{\Ren}\left(\dfrq{v^*}{x} + \dfrq{v^*}{y}\right)
       = -\tau\dfr{p}{y} + v.
\f}

Тогда уравнение для поправки \f(u'\f) запишем вычтя последнее выражение из
уравнения \f(\eqref{eq:ns2d_semi_u}\f), умноженного на \f(\tau\f):

\f{equation}{
    \label{eq:ns2d_ustroke}
    u' + \tau\dfr{u u'}{x} + \tau\dfr{v u'}{y}
       - \frac{\tau}{\Ren}\left(\dfrq{u'}{x} + \dfrq{\hat u'}{y}\right)
       = -\tau\dfr{p'}{x}.
\f}

Основная идея алгоритма SIMPLE заключается в приближённом представлении выражения \f(\eqref{eq:ns2d_ustroke}\f)
в явном виде относительно поправки. Для этого все дифференциальные операторы, включающие в себя поправку скорости,
из выражения убираются, а для компенсации в правую часть добавляется множитель \f(d^u\f):

\f{equation}{
    \label{eq:ns2d_ustroke_approx}
    u' \approx -\tau d^u(x, y) \dfr{p'}{x}.
\f}

Аналогичные рассуждения в отношении поправки поперечной скорости \f(v'\f) приводят к выражению

\f{equation}{
    \label{eq:ns2d_vstroke_approx}
    v' \approx -\tau d^v(x, y) \dfr{p'}{y}.
\f}

К точному определению значения полей \f(d^u\f), \f(d^v\f) вернёмся позднее, когда будем расписывать
эти выражения на матричном уровне.

Далее используем уравнение неразрывности \f(\eqref{eq:ns2d_semi_div}\f). Подставим
в него разложения \f(\eqref{eq:ns2d_decomp}\f) и используем
\f(\eqref{eq:ns2d_ustroke_approx}-\eqref{eq:ns2d_vstroke_approx}\f).
Тогда
получим уравнение Пуассона с непостоянным по пространству векторным коэффициентом диффузии \f(\left(d^u, d^v\right)\f)
относительно поправки давления \f(p'\f):
\f{equation}{
    \label{eq:ns2d_pstroke_diff}
    -\left[
    \dfr{}{x}\left(
       d^u \dfr{p'}{x} 
            \right)
    +\dfr{}{y}\left(
       d^v \dfr{p'}{y} 
            \right)
    \right]
    =
    -\frac{1}{\tau}\left(
            \dfr{u^*}{x} + \dfr{v^*}{y}
    \right).
\f}

Определим порядок вычислений на итерационном слое.
Напомним, что значения \f(u, v, p\f) с
предыдущего слоя нам известно и задача
состоит в нахождении значений \f(\hat u, \hat v, \hat p\f)
на текущем слое.

1. Из уравнений \f(\eqref{eq:ns2d_ustar}, \eqref{eq:ns2d_vstar}\f)
   вычисляются значения \f(u^*, v^*\f);
2. Они используются для вычисления правой части уравнения \f(\eqref{eq:ns2d_pstroke_diff}\f),
   в результате решения которого находится поправка давления \f(p'\f);
3. Дифференцируя найденную поправку давления найдём поправки скорости \f(u', v'\f)
   из выражений \f(\eqref{eq:ns2d_ustroke_approx}, \eqref{eq:ns2d_vstroke_approx}\f);
4. Окончательно выразим значения переменных для текущего слоя из \f(\eqref{eq:ns2d_decomp}\f).
   Для улучшения стабильности алгоритма значение давления вычисляют
   с некоторым коэффициентом релаксации \f(\alpha_p\f):
   \f{equation*}{
        \hat p = p + \alpha_p p';
   \f}
5. Далее проводится вычисление невязки с ипользованием найденных значений \f(\hat u, \hat v, \hat p\f)
   из выражения \f(\eqref{eq:ns2d_residual}\f). Если она недостаточно мала,
   то выполняется присваивание
   \f(
        u = \hat u, \; v=\hat v, \; p = \hat p
   \f) 
   и возвращение на шаг 1.

Полученные на каждом шаге итерационного процесса компоненты скорости \f(\hat u, \hat v\f)
точно удовлетворяют уравнению неразрывности \f(\eqref{eq:ns2d_semi_div}\f) в "чёрных" узлах сетки, но
уравнения движения \f(\eqref{eq:ns2d_semi_u}, \eqref{eq:ns2d_semi_v}\f) выполняются лишь приближённо.

Всего в алгоритме SIMPLE есть два параметра: коэффициент
релаксации \f(\alpha_p\f) и фиктивный шаг по времени \f(\tau\f).
Для лучшей сходимости рекомендуется использовать значения
\f{align}{
    \label{eq:ns2d_simple_params}
    &\alpha_p = 0.8,\\
    \nonumber
    &\tau = \frac{\Ren h_x^2 h_y^2}{2(h_x^2 + h_y^2)}.
\f}

## Пространственная аппроксимация

Для численной реализации алгоритма решения
необходимо провести пространственную аппроксимацию полудискретизованных
выражений \f(\eqref{eq:ns2d_ustar}, \eqref{eq:ns2d_vstar}, \eqref{eq:ns2d_ustroke_approx},
        \eqref{eq:ns2d_vstroke_approx}, \eqref{eq:ns2d_pstroke_diff}\f).

### Разнесённая сетка

Будем использовать структурированную четырёхугольную сетку
с постоянным шагом по пространству.
При этом неизвестные параметры будем задавать
по схеме, представленной на рисунке:

\image html staggered_grid.png width=500

Введём разбиение сетки: \f(n_x\f) -- количество ячеек в направлении \f(x\f),
    \f(n_y\f) -- количество ячеек в направлении \f(y\f).

Очевидно, что при использовании такого разнесённого шаблона,
количество точек, в которых заданы значения, будет
различным для разных параметров.
Так количество узловых значений давления будет равно \f(n_x \times n_y\f),
продольной скорости \f(u\f) -- \f((n_x+1) \times n_y\f), а поперечной \f(v\f) -- \f(n_x \times (n_y+1)\f).

Использование такого расположения узловых точек
даёт преимущество при аппроксимации
первых производных. Так, конечная разность
\f{equation*}{
\left.\dfr{p}{x}\right|_{i, j+\tfrac12} = \frac{p_{i+\tfrac12,j+\tfrac12} - p_{i-\tfrac12,j+\tfrac12}}{h_x} + o(h_x^2)
\f}
будем симметричной в узле \f(i,j+\tfrac12\f), где задана
компонента скорости \f(u\f), и поэтому будет иметь там второй порядок точности.

Выражения \f(\eqref{eq:ns2d_ustar}, \eqref{eq:ns2d_ustroke_approx}\f) аппроксимируются
на сетке для \f(u\f), выражения \f(\eqref{eq:ns2d_vstar}, \eqref{eq:ns2d_vstroke_approx}\f) -- 
на сетке для \f(v\f), а \f(\eqref{eq:ns2d_pstroke_diff}\f) -- на сетке для \f(p\f).

Введём сквозную линейную нумерацию узлов сетки: нулевой узел разположим в левом нижнем углу,
далее будем индексировать слева направа и потом снизу вверх.
Для основной сетки перевод двумерного индекса \f(i,j\f) в сквозной индекс будет проводится по формуле
\f{equation}{
    \label{eq:ns2d_kij}
    k(i,j) = j(n_x+1)+i.
\f}
Для сеток, на которых заданы сеточные параметры, такой перевод примет вид
\f{align}{
    \label{eq:ns2d_kipjp}
    &k(i+\tfrac12,j+\tfrac12) = jn_x + i, \quad - \; \text{сетка для давления } p\\[10pt]
    \label{eq:ns2d_kijp}
    &k(i,j+\tfrac12) = j(n_x+1) + i, \quad - \;  \text{сетка для продольной скорости } {\color{red} u} \\[10pt]
    \label{eq:ns2d_kipj}
    &k(i+\tfrac12,j) = jn_x + i, \quad - \; \text{сетка для поперечной скорости } {\color{blue} v} \\[10pt]
\f}

### Уравнения движения

Запишем конечноразностную аппроксимацию уравнения \f(\eqref{eq:ns2d_ustar}\f) для пробной скорости \f(u^*\f) в "красных" узлах сетки
\f(\left(i, j+\tfrac12\right)\f):

\f{align}{
    \label{eq:ns2d_ustar_discr}
    u^*_{i, j+\tfrac12} 
        &+ \frac{\tau}{h_x}
          \left(
            \left(u u^*\right)_{i+\tfrac12,j+\tfrac12}-
            \left(u u^*\right)_{i-\tfrac12,j+\tfrac12}
          \right)  \\[10pt]
    \nonumber
        &+ \frac{\tau}{h_y}
          \left(
            \left(v u^*\right)_{i,j+1}-
            \left(v u^*\right)_{i,j}
          \right)   \\[10pt]
    \nonumber
       &-\frac{1}{\Ren}\frac{\tau}{h_x^2}
          \left(
            u^*_{i-1,j+\tfrac12} - 2 u^*_{i,j+\tfrac12} + u^*_{i+1,j+\tfrac12}
          \right)   \\[10pt]
    \nonumber
       &-\frac{1}{\Ren}\frac{\tau}{h_y^2}
          \left(
            u^*_{i,j-\tfrac12} - 2 u^*_{i,j+\tfrac12} + u^*_{i,j+\tfrac32}
          \right)   \\[10pt]
    \nonumber
       &= u_{i,j+\tfrac12} -\frac{\tau}{h_x}\left(p_{i+\tfrac12,j+\tfrac12} - p_{i-\tfrac12,j+\tfrac12}\right).
\f}

В приведённом выражении
за исключением конвективных слагаемых вида \f(u u\f) все остальные
сеточные вектора используются на своих сетках.
Конвективные слагаемые распишем через полусуммы вида:
\f{equation*}{
    u_{i+\tfrac12} = \frac{u_{i} + u_{i+1}}{2} + o(h^2)
\f}

Тогда
\f{align*}{
    \left(u u^*\right)_{i+\tfrac12,j+\tfrac12} =&
        \left(u_{i+\tfrac12,j+\tfrac12} \vphantom{u^*_{\tfrac12}}\right)\left(u^*_{i+\tfrac12,j+\tfrac12}\right) =
        \frac14 \left(u_{i, j+\tfrac12} + u_{i+1,j+\tfrac12}\vphantom{u^*_{\tfrac12}}\right)
                \left(u^*_{i, j+\tfrac12} + u^*_{i+1,j+\tfrac12}\right), \\[10pt]
    \left(u u^*\right)_{i-\tfrac12,j+\tfrac12} =&
        \frac14 \left(u_{i, j+\tfrac12} + u_{i-1,j+\tfrac12}\vphantom{u^*_{\tfrac12}}\right)
                \left(u^*_{i, j+\tfrac12} + u^*_{i-1,j+\tfrac12}\right), \\[10pt]
    \left(v u^*\right)_{i,j+1} =&
        \frac14 \left(v_{i+\tfrac12, j+1} + v_{i-\tfrac12,j+1}\vphantom{u^*_{\tfrac12}}\right)
                \left(u^*_{i, j+\tfrac32} + u^*_{i,j+\tfrac12}\right), \\[10pt]
    \left(v u^*\right)_{i,j} =&
        \frac14 \left(v_{i+\tfrac12, j} + v_{i-\tfrac12,j}\vphantom{u^*_{\tfrac12}}\right)
                \left(u^*_{i, j+\tfrac12} + u^*_{i,j-\tfrac12}\right).
\f}

Схему \f(\eqref{eq:ns2d_ustar_discr}\f) можно записать в виде системы линейных уравнений вида
\f{equation}{
    \label{eq:ns2d_ustar_slae}
    A^u u^* = b^{u}.
\f}
Сеточная матрица \f(A^u\f) будет иметь \f((n_x+1)n_y\f) строк.
Для строки, соответствующей \f(\left(i,j+\tfrac12\right)\f) узлу ненулевыми будут столбцы,
соответствующие узлам:
- \f(\left(i,j+\tfrac12\right)\f),
- \f(\left(i+1,j+\tfrac12\right)\f),
- \f(\left(i-1,j+\tfrac12\right)\f),
- \f(\left(i,j+\tfrac32\right)\f),
- \f(\left(i,j-\tfrac12\right)\f).
В случае использования стандартной нумерации узлов структурированной сетки,
когда нулевой индекс соответствуют левому нижнему узлу и далее нумерация идёт
с быстрым индексом \f(i\f), то матрица будет пятидиагональной.


Подставим полученные выражения в конвективную часть выражения \f(\eqref{eq:ns2d_ustar_discr}\f).
Множитель при диагональном элементе \f(u^*_{i,j+\tfrac12}\f) будет равен:
\f{align*}{
        \frac{\tau}{4}\Biggl(
         \underbrace{\frac{u_{i,j+\tfrac12} - u_{i-1,j+\tfrac12}}{h_x}}_{\left.\ddfr{u}{x}\right|_{i-\tfrac12,j+\tfrac12}}
        +\underbrace{\frac{u_{i+1,j+\tfrac12} - u_{i,j+\tfrac12}}{h_x}}_{\left.\ddfr{u}{x}\right|_{i+\tfrac12,j+\tfrac12}}
        +\underbrace{\frac{v_{i+\tfrac12,j+1} - v_{i+\tfrac12,j}}{h_y}}_{\left.\ddfr{v}{y}\right|_{i+\tfrac12,j+\tfrac12}}
        +\underbrace{\frac{v_{i-\tfrac12,j+1} - v_{i-\tfrac12,j}}{h_y}}_{\left.\ddfr{v}{y}\right|_{i-\tfrac12,j+\tfrac12}}
        \Biggr)
\f}

Сумма первого и четвёртого слагаемых представляет собой разностный
аналог уравнения неразрывности \f(\eqref{eq:ns2d_semi_div}\f), записанной для "чёрного" узла
сетки \f(i-\tfrac12, j+\tfrac12\f) относительно компонент
скорости с предыдущей итерации.
Как было сказано ранее,
в настоящем алгоритме
уравнение неразрывности для итоговых по результатам итерации скорости в этих узлах выполняется точно.
Поэтому эта сумма в точности будет равна нулю. Аналогичный результат получится
и для суммы второго и третьего слагаемых. Отсюда следует вывод, что
конвективное слагаемое не даёт вклад в диагональ итоговой матрицы (как и следовало ожидать от симметричной аппроксимации).

Окончательно запишем все пять ненулевых вхождений в строку матрицы:
\f{align}{
    \label{eq:ns2d_au}
    A^u\left[
        k\left(i,j+\tfrac12\right),
        k\left(i,j+\tfrac12\right)\right]
        &= 1 + \frac{2\tau}{\Ren}\left(\frac{1}{h_x^2} + \frac{1}{h_y^2}\right)
        \quad - \;\text{основная диагональ}, \\[10pt]
    \nonumber
    A^u\left[
        k\left(i,j+\tfrac12\right),
        k\left(i+1,j+\tfrac12\right)\right]
        &= -\frac{\tau}{\Ren}\frac{1}{h_x^2}
           +\frac{\tau}{4h_x}\left(u_{i,j+\tfrac12}+u_{i+1,j+\tfrac12}\right)
        \quad - \;\text{первая верхняя диагональ}, \\[10pt]
    \nonumber
    A^u\left[
        k\left(i,j+\tfrac12\right),
        k\left(i-1,j+\tfrac12\right)\right]
        &= -\frac{\tau}{\Ren}\frac{1}{h_x^2}
           -\frac{\tau}{4h_x}\left(u_{i,j+\tfrac12}+u_{i-1,j+\tfrac12}\right)
        \quad - \;\text{первая нижняя диагональ}, \\[10pt]
    \nonumber
    A^u\left[
        k\left(i,j+\tfrac12\right),
        k\left(i,j+\tfrac32\right)\right]
        &= -\frac{\tau}{\Ren}\frac{1}{h_y^2}
           +\frac{\tau}{4h_y}\left(v_{i+\tfrac12,j+1}+v_{i-\tfrac12,j+1}\right)
        \quad - \;\text{вторая верхняя диагональ}, \\[10pt]
    \nonumber
    A^u\left[
        k\left(i,j+\tfrac12\right),
        k\left(i,j-\tfrac12\right)\right]
        &= -\frac{\tau}{\Ren}\frac{1}{h_y^2}
           -\frac{\tau}{4h_y}\left(v_{i+\tfrac12,j}+v_{i-\tfrac12,j}\right)
        \quad - \;\text{вторая нижняя диагональ}.
\f}
Здесь \f(k(i,j)\f) -- функция перевода двумерного индекса в сквозной \f(\eqref{eq:ns2d_kijp}\f).

Аналогичные выкладки для второго из уравнений движения \f(\eqref{eq:ns2d_vstar}\f)
дают систему уравнений
\f{equation}{
    \label{eq:ns2d_vstar_slae}
    A^v v^* = b^{v},
\f}
элементы пятидиагональной матрицы которой имеют вид
\f{align}{
    \label{eq:ns2d_av}
    A^v\left[
        k\left(i+\tfrac12,j\right),
        k\left(i+\tfrac12,j\right)\right]
        &= 1 + \frac{2\tau}{\Ren}\left(\frac{1}{h_x^2} + \frac{1}{h_y^2}\right)
        \quad - \;\text{основная диагональ}, \\[10pt]
    \nonumber
    A^v\left[
        k\left(i+\tfrac12,j\right),
        k\left(i+\tfrac32,j\right)\right]
        &= -\frac{\tau}{\Ren}\frac{1}{h_x^2}
           +\frac{\tau}{4h_x}\left(u_{i+1,j+\tfrac12}+u_{i+1,j-\tfrac12}\right)
        \quad - \;\text{первая верхняя диагональ}, \\[10pt]
    \nonumber
    A^v\left[
        k\left(i+\tfrac12,j\right),
        k\left(i-\tfrac12,j\right)\right]
        &= -\frac{\tau}{\Ren}\frac{1}{h_x^2}
           -\frac{\tau}{4h_x}\left(u_{i,j+\tfrac12}+u_{i,j-\tfrac12}\right)
        \quad - \;\text{первая нижняя диагональ}, \\[10pt]
    \nonumber
    A^v\left[
        k\left(i+\tfrac12,j\right),
        k\left(i+\tfrac12,j+1\right)\right]
        &= -\frac{\tau}{\Ren}\frac{1}{h_y^2}
           +\frac{\tau}{4h_y}\left(v_{i+\tfrac12,j}+v_{i+\tfrac12,j+1}\right)
        \quad - \;\text{вторая верхняя диагональ}, \\[10pt]
    \nonumber
    A^v\left[
        k\left(i+\tfrac12,j\right),
        k\left(i+\tfrac12,j-1\right)\right]
        &= -\frac{\tau}{\Ren}\frac{1}{h_y^2}
           -\frac{\tau}{4h_y}\left(v_{i+\tfrac12,j}+v_{i+\tfrac12,j-1}\right)
        \quad - \;\text{вторая нижняя диагональ}.
\f}
Правая часть аппроксимируется в виде
\f{equation*}{
    b^{v^*}[k(i+\tfrac12, j)] = 1 - \frac{\tau}{h_y}\left(p_{i+\tfrac12, j+1} - p_{i+\tfrac12,j}\right).
\f}
Используется функция перевода двумерного индекса в сквозной из \f(\eqref{eq:ns2d_kipj}\f).

### Уравнение для поправки давления
Распишем уравнение \f(\eqref{eq:ns2d_pstroke_diff}\f)
на "чёрной" сетке методом конечных разностей.
Для первого слагаемого получим
\f{equation}{
\label{eq:ns2d_d2pdx2}
\begin{array}{ll}
\left.\ddfr{}{x}\left(d^u \ddfr{p'}{x}\right) \right|_{i+\tfrac12, j+\tfrac12}
    &\approx
        \dfrac{1}{h_x}\left(
            d^u_{i+1, j+\tfrac12} \left. \ddfr{p'}{x} \right|_{i+1, j+\tfrac12} -
            d^u_{i, j+\tfrac12} \left. \ddfr{p'}{x} \right|_{i, j+\tfrac12}
        \right) \\[10pt]

    &=
        \dfrac{1}{h_x}\left(
            d^u_{i+1, j+\tfrac12} \dfrac{p'_{i+\tfrac32,j+\tfrac12} - p'_{i+\tfrac12,j+\tfrac12}}{h_x} - 
            d^u_{i, j+\tfrac12}  \dfrac{p'_{i+\tfrac12,j+\tfrac12} - p'_{i-\tfrac12,j+\tfrac12}}{h_x}
        \right).
\end{array}
\f}
Аналогично расписываются остальные слагаемые. В результате получим систему линейных уравнений вида
\f{equation}{
    \label{eq:ns2d_pstroke_slae}
    A^p p' = b^p,
\f}
где ненулевые коэффициенты пятидиагональной матрицы примут вид
\f{align}{
    \label{eq:ns2d_ap}
    A^p[k(i+\tfrac12, j+\tfrac12), k(i+\tfrac12, j+\tfrac12)] =&
        \frac{1}{h_x^2}\left( d^u_{i+1,j+\tfrac12} + d^u_{i,j+\tfrac12} \right)
        +\frac{1}{h_y^2}\left( d^v_{i+\tfrac12,j} + d^v_{i+\tfrac12,j+1} \right), \\[10pt]
    \nonumber
    A^p[k(i+\tfrac12, j+\tfrac12), k(i+\tfrac32, j+\tfrac12)] =&
        -\frac{1}{h_x^2}d^u_{i+1,j+\tfrac12}, \\[10pt]
    \nonumber
    A^p[k(i+\tfrac12, j+\tfrac12), k(i-\tfrac12, j+\tfrac12)] =&
        -\frac{1}{h_x^2}d^u_{i,j+\tfrac12}, \\[10pt]
    \nonumber
    A^p[k(i+\tfrac12, j+\tfrac12), k(i+\tfrac12, j+\tfrac32)] =&
        -\frac{1}{h_y^2}d^v_{i+\tfrac12,j+1}, \\[10pt]
    \nonumber
    A^p[k(i+\tfrac12, j+\tfrac12), k(i+\tfrac12, j-\tfrac12)] =&
        -\frac{1}{h_y^2}d^v_{i+\tfrac12,j}.\\[10pt]
\f}
Столбец свободных членов аппроксимируется в виде
\f{equation}{
    \label{eq:ns2d_bp}
    b^p[k(i+\tfrac12,j+\tfrac12)] = 
        -\frac{1}{\tau}
        \left(
              \frac{u^*_{i+1,j+\tfrac12} - u^*_{i,j+\tfrac12}}{h_x}
            + \frac{v^*_{i+\tfrac12,j+1} - v^*_{i+\tfrac12,j}}{h_y}
        \right).
\f}
Здесь используется функция перевода двумерного индекса в сквозной из \f(\eqref{eq:ns2d_kipjp}\f).

Далее определим значения \f(d^u, d^v\f).
Согласно идее алгоритма SIMPLE \f(d^u\f) должна
быть такой функцией, которая максимально приближает
выражение \f(\eqref{eq:ns2d_ustroke}\f) к \f(\eqref{eq:ns2d_ustroke_approx}\f).

Пространственная аппроксимация выражения \f(\eqref{eq:ns2d_ustroke}\f)
приводит к системе уравнений
\f{equation*}{
    A^u u' = -\tau\dfr{p'}{x}
\f}
где матрица \f(A^u\f) -- та же самая матрица, которая использовалась
при аппроксимации уравнения движения \f(\eqref{eq:ns2d_ustar_discr}\f).

Сравнивая предыдущее выражение с \f(\eqref{eq:ns2d_ustroke_approx}\f)
сделаем вывод, что \f(d^u\f) должна быть такой, чтобы
\f{equation*}{
    d^u \dfr{p'}{x} \approx \left(A^u\right)^{-1} \dfr{p'}{x}.
\f}
То есть поэлементное умножение сеточного вектора \f({d^u}\f) 
на другой вектор
должно действовать похоже на умножение обратной к \f(A^u\f) матрицы на этот же самый вектор.

Исходя из свойств матрицы \f(A^u\f) \f(\eqref{eq:ns2d_au}\f) можно
положить 
\f{equation}{
    \label{eq:ns2d_du}
    d^u = \left({\rm diag}\left(A^u\right)\right)^{-1} = 
        \left(1 + \frac{2\tau}{\Ren}\left(\frac{1}{h_x^2} + \frac{1}{h_y^2}\right)\right)^{-1}
\f}
и аналогично из \f(\eqref{eq:ns2d_av}\f)
\f{equation}{
    \label{eq:ns2d_dv}
    d^v = \left({\rm diag}\left(A^v\right) \right)^{-1}= 
        \left(1 + \frac{2\tau}{\Ren}\left(\frac{1}{h_x^2} + \frac{1}{h_y^2}\right)\right)^{-1}.
\f}
Таким образом мы получили выражения для коэффициентов уравнения для поправки давления,
которые зависят только от разбиения сетки.
В случае, если разбиение равномерное (\f(h_x = {\rm const}, h_y = {\rm const}\f)),
то все значения коэффициентов одинаковы.
Однако, для неравномерных разбиений, они будут зависеть
от пространства и задаваться на "красной" (для \f(d^u\f)) и "синей" (для \f(d^v\f))
сетках.

В результате использования \f(\eqref{eq:ns2d_du}, \eqref{eq:ns2d_dv}\f) левая часть системы уравнений \f(\eqref{eq:ns2d_pstroke_slae}\f)
будет постоянна на всех итерациях, что удобно для инициализации алгебраических решателей этой системы
(можно провести инициализацию один раз до начала счёта).

Это отличает эту систему от двух других систем, возникающих
из аппроксимации уравнений движения \f(\eqref{eq:ns2d_ustar_slae}, \eqref{eq:ns2d_vstar_slae}\f),
левые части которых зависят от значений с предыдущих
итерационных слоёв. Этот момент обуславливает выбор
решателей для этих систем, которые в эффективных гидродинамических кодах обычно
отличаются, от решателя для системы \f(\eqref{eq:ns2d_pstroke_slae}\f).


### Уравнение для поправки скорости
И наконец рассмотрим аппроксимацию выражений \f(\eqref{eq:ns2d_ustroke_approx}\f),
\f(\eqref{eq:ns2d_vstroke_approx}\f), которые примут явный вид
\f{align}{
    \label{eq:ns2d_ustroke_discr}
    u'_{i,j+\tfrac12} = -\tau d^u_{i,j+\tfrac12} \frac{p'_{i+\tfrac12,j+\tfrac12} - p'_{i-\tfrac12, j+\tfrac12}}{h_x}, \\[10pt]
    \label{eq:ns2d_vstroke_discr}
    v'_{i+\tfrac12,j} = -\tau d^v_{i+\tfrac12,j} \frac{p'_{i+\tfrac12,j+\tfrac12} - p'_{i+\tfrac12, j-\tfrac12}}{h_x}. \\[10pt]
\f}

## Учёт граничных условий {#simple-bc}

Для уравнений Навье-Стокса на каждой границе расчётной области
требуется столько условий, сколько есть уравнений движения.
Для двумерной задачи \f(\eqref{eq:ns2d_u}-\eqref{eq:ns2d_div}\f)
нужно задать два граничных условия.

При использовании разнесённой сетки граница области проходит
по граням основной сетки. 
На нижней и верхней границах расчётной области
присутствуют узлы для \f(v\f), но отсутствуют
узлы для \f(u\f).
На правой и левой границах, наоборот,
есть узлы с заданными компонентами \f(u\f),
но нет узлов с компонентами \f(v\f).
Узловые значения для давления \f(p\f)
никогда не бывают граничными.

Для простоты пока будем рассматривать только случай с заданными значениями
двух компонент скорости на каждой из границ задачи:
\f{align*}{
    &\left. u(x, y) \right|_{x,y\in\Gamma} = u^\Gamma(x, y), \\
    &\left. v(x, y) \right|_{x,y\in\Gamma} = v^\Gamma(x, y).
\f}

В схеме SIMPLE частные граничные условия 
для скорости учитываются при решении задачи
для пробных скоростей \f(u^*, v^*\f).
Тогда для поправки скорости \f(u', v'\f) на границах
будут справедливы соответствующие однородные граничные условия (нулевые значения в нашем случае):

\f{align}{
    \label{eq:ns2d_usplit_bc}
    &\left. u^*(x, y) \right|_{x,y\in\Gamma} = u^\Gamma(x, y), \\
    \nonumber
    &\left. v^*(x, y) \right|_{x,y\in\Gamma} = v^\Gamma(x, y), \\
    \nonumber
    &\left. u'(x, y) \right|_{x,y\in\Gamma} = 0,\\
    \nonumber
    &\left. v'(x, y) \right|_{x,y\in\Gamma} = 0.
\f}

Для учёта граничных условий по скорости требуется модифицировать
системы линейных уравнений \f(\eqref{eq:ns2d_ustar_slae}, \eqref{eq:ns2d_vstar_slae}\f).

Рассмотрим нижнюю границу \f(j=0\f).

На нижней границе явно присутствуют узлы "синей" сетки.
Значит можно явно установить значения для скорости \f(v\f)
путём постановки нулей с единицой на диагонали в строке матрицы и отнесением необходимого
граничного значение в правый вектор столбец системы \f(\eqref{eq:ns2d_vstar_slae}\f):
\f{align}{
    \label{eq:ns2d_bc1}
    &A^v[k(i+\tfrac12, 0), s] = \delta_{ks}, \quad \forall i, \; \forall s\\[10pt]
    \nonumber
    &b^{v}[k(i+\tfrac12, 0)] = v^\Gamma.
\f}
Такая модификация просто заменяет \f(k(i+\tfrac12, 0)\f) -ое уравнение
системы \f(\eqref{eq:ns2d_vstar_slae}\f) на выражение
\f{equation*}{
    v^*_{i+\tfrac12, 0} = v^\Gamma.
\f}

Узлов для компонет \f(u\f) на нижней границе нет.
Рассмотрим первый ряд точек "красной" сетки: \f((i, \tfrac12)\f).
Если бы мы захотели заполнить коэффициенты системы
линейных уравнений \f(\eqref{eq:ns2d_ustar_slae}\f)
по выведенным выше формулам \f(\eqref{eq:ns2d_au}\f)
для узла, расположенного в этом ряду, мы бы столкнулись
с необходимостью установки значения в фиктивную колонку:
последнее из уравнений \f(\eqref{eq:ns2d_au}\f)
предписывает нам установить значение по адресу
\f([k(i, \tfrac12), k(i, -\tfrac12)]\f), который, очевидно, не присутствует в матрице.

Действительно, \f(k(i,\tfrac12)\f)-ая строка системы уравнений \f(\eqref{eq:ns2d_au}\f)
имеет вид
\f{equation}{
    \label{eq:ns2d_au_low}
      D    u^*_{i, \tfrac12}
    + U^1  u^*_{i+1, \tfrac12}
    + L^1  u^*_{i-1, \tfrac12}
    + U^2 u^*_{i, \tfrac32}
    + L^2 u^*_{i, -\tfrac12} 
    = b^u_{i, \tfrac12},
\f}
где \f(D\f) -- коэффициент с основной диагонали, \f(U^{1,2}, L^{1,2}\f) -- 
коэффициенты с двух верхних и двух нижних диагоналей, вычисляемые по формулам \f(\eqref{eq:ns2d_au}\f).
Вторая нижняя диагональ у этой строки матрицы отсутствует.
Она соответствует вкладу от узла \f((i, -\tfrac12)\f), который лежит вне области расчёта, на полшага ниже
нижней границе.

Тем не менее, такой фиктивный узел мы можем 
использовать для записи аппроксимации
\f{equation*}{
    u^*_{i,0} = u^\Gamma = \frac{u^*_{i,\tfrac12} + u^*_{i, -\tfrac12}}{2} + o(h_x^2).
\f}
или
\f{equation*}{
    u^*_{i, -\tfrac12} \approx 2u^\Gamma - u^*_{i,\tfrac12}.
\f}

Подставляя это выражение в строку \f(\eqref{eq:ns2d_au_low}\f) получим
\f{equation*}{
      (D - L^2) u^*_{i, \tfrac12}
    + U^1       u^*_{i+1, \tfrac12}
    + L^1       u^*_{i-1, \tfrac12}
    + U^2       u^*_{i, \tfrac32}
    = b^u_{i, \tfrac12} + 2 u^\Gamma.
\f}

Таким образом, добавление коэффициента в фиктивную колонку строки матрицы при
наличие условия первого рода на границе равносильно
вычитанию этого коэффициента из диагонального элемента этой строки
и вычитанием удвоенного граничного значения из правой части.
В случае нижней границы получим
\f{align}{
    \label{eq:ns2d_bc2}
    &A^u[k(i, \tfrac12), k(i, \tfrac12)] \mathrel{-}= A^u[k(i, -\tfrac12)], \\[10pt]
    \nonumber
    &b^u[k(i, \tfrac12)] \mathrel{-}= 2 u^\Gamma.
\f}

Приёмы \f(\eqref{eq:ns2d_bc1}, \eqref{eq:ns2d_bc2}\f)
используются и на остальных границах для
постановки граничных условий для скорости.

При сборке системы линейных уравнений для
поправки давления \f(\eqref{eq:ns2d_pstroke_slae}\f)
так же возникает проблема с обращением
к фиктивным узлам. Например, при рассмотрении левой стенки (\f(i=0\f)
третье из уравнений \f(\eqref{eq:ns2d_ap}\f) описывает
несуществующий столбец \f(k(-\tfrac12, j+\tfrac12)\f).
Если обратиться к выражению \f(\eqref{eq:ns2d_d2pdx2}\f),
то будет видно, что это слагаемое пришло в результате
расписывания граничной производной \f(p'\f),
которая, исходя из выражения \f(\eqref{eq:ns2d_ustroke_approx}\f) пропорциональна граничному значению \f(u'\f),
то есть, вспоминая \f(\eqref{eq:ns2d_usplit_bc}\f), равна нулю:
\f{equation*}{
\left. \dfr{p'}{x} \right|_{0,j+\tfrac12} = -\frac{1}{\tau d^u} u'_{0,j+\tfrac12} = 0.
\f}

То есть добавлять слагаемые, соответствующие фиктивным узлам, в матрицу \f(A^p\f) не нужно.
Не нарушая общности выведённых ранее выражений \f(\eqref{eq:ns2d_ap}\f),
просто модифицируем значения коэффициентов \f(d^u, d^v\f):
\f{align}{
    \label{eq:ns2d_bc3}
    d^u_{0, j+\tfrac12} = d^u_{n_x+1, j+\tfrac12} = 0, \\[10pt]
    \nonumber
    d^v_{i+\tfrac12, 0} = d^u_{i+\tfrac12, n_y+1} = 0.
\f}

В исходных уравнениях
\f(\eqref{eq:ns2d_u}-\eqref{eq:ns2d_div}\f)
давление присутствует только в виде своих производных.
Если в задаче нигде не задано явное граничное условие
для давления, то решение для давления
будет определено только с точностью до константы.
Чтобы убрать эту неопределённость
рекомендуется явно положить давление нулю
в любом узле. Например, в случае нулевого узла,
по аналогии с \f(\eqref{eq:ns2d_bc1}\f) запишем:
\f{align}{
    \label{eq:ns2d_bc4}
    &A^p[k(\tfrac12, \tfrac12), s] = \delta_{ks}, \\[10pt]
    \nonumber
    &b^{p}[k(\tfrac12, \tfrac12)] = 0.
\f}

## Программная реализация

### Задача о двумерном течении в каверне

Для иллюстрации работы алгоритма рассмотрим задачу о 
течении в каверне. Постановку задачи представлена на рисунке

\image html cavern2d.png width=300

Задача реализована в тесте `[cavern2-simple]` в файле `cavern_2d_simple_test.cpp`.

Программа проводит итерации стартуя от начального нулевого состояния
\f(u=v=p=0\f) до тех пор, пока невязка не достигнет заданного порога.
На каждой итерации поле давления и векторное поле скорости сохраняются
на основной сетке в файл `cavern2.vtk.series`.

Итоговый результат (для \f(\eps=10^{-2}\f)) представлен на картинке

\image html cavern2d-result.png width=600

Для отображения вектора поля скорости в Paraview см. \ref paraview-glyph "справку".

Для работы с разнесённой сеткой в классе cfd::RegularGrid2D
представлены функции
- cfd::RegularGrid2D::cell_centered_grid()  -- построить сетку по центрам ячеек ("чёрную" сетку для \f(p\f)),
- cfd::RegularGrid2D::xface_centered_grid() -- построить сетку по центрам \f(x\f)-граней ("синюю" сетку для \f(v\f)),
- cfd::RegularGrid2D::yface_centered_grid() -- построить сетку по центрам \f(y\f)-граней ("красную" сетку для \f(u\f)),

и функции перевода индексов
- cfd::RegularGrid2D::cell_centered_grid_index_ip_jp -- посчитать линейный индекс "чёрной" сетки \f(\eqref{eq:ns2d_kipjp}\f),
- cfd::RegularGrid2D::xface_grid_index_ip_j -- посчитать линейный индекс "синей" сетки \f(\eqref{eq:ns2d_kipj}\f),
- cfd::RegularGrid2D::yface_grid_index_i_jp -- посчитать линейный индекс "красной" сетки \f(\eqref{eq:ns2d_kijp}\f).



### Функция верхнего уровня
\dontinclude{lineno} cavern_2d_simple_test.cpp
\skip "[cavern2-simple]"
\until TEST_CASE

Сначала устанавливаются параметры задачи:
число Рейнолдса,
\skip Re
\until Re
параметры алгоритма SIMPLE \f(\eqref{eq:ns2d_simple_params}\f),
\skip tau
\until alpha
разбиение сетки, 
\skip n_cells
\until n_cells
максимальное количество итераций 
\skip max_it
\until max_it
и значение невязки, при котором итерации прекращаются
\skip eps
\until eps

Затем происходит инициализация решателя, который
определён в классе `Cavern2DSimpleWorker`
\skip Cavern2DSimpleWorker
\until Cavern2DSimpleWorker
и параметров сохранения. Здесь
первым параметром является флаг сохранения
точных сеточных значений, который установлен в `false`,
а также имя файла с итоговым результатом.
Таким образом сохраняться будет только решение,
интерполированное на основную сетку.
Для целей отладки программы (для просмотра действительных, не интерполированных полей решения)
следует первый флаг установить в `true`. Тогда помимо `cavern2.vtk.series`, будут
создаваться также файлы `cavern2-u`, `cavern2-v`, `cavern2-p`.
\until _saver

Потом происходит установка начальных значений искомых сеточных векторов: \f(u=v=p=0\f)
\skip u_init
\until save_current_field

и начинается итерационный процесс.
\skip for
\until for

Внутри цикла
выполняется шаг итерационного процесса, который
возвращает значение итоговой невязки в переменную `nrm`.
\skip step
\until step

На печать выводится индекс итерации, значение невязки и значение давления в правом верхнем узле (для контроля сходимости)
\skip cout
\until cout

Сохраняется состояние решателся на пройденную итерацию
\skip save_current
\until save_current

и производится проверка на сходимость
\skip eps
\until }

В конце производится проверка: при установленных параметрых решение
должно сойтись за 9 итераций:
\skip CHECK
\until CHECK

### Поля класса решателя
\dontinclude{lineno} cavern_2d_simple_test.cpp
Класс `Cavern2DSimpleWorker` хранит в себе набор полей,
характеризующих состояние итерационного процесса.
Некоторые из этих полей (параметры решателя) постоянны (`const`) и
определяются непосредственно перед вызовом конструктора в инициализаторе. Другие
меняются с продвижением по итерациям.

Среди постоянных полей заданы 4 сетки: основная `_grid`,
"чёрная" сетка `_cc_grid` (cell_centered) для давления,
"красная" сетка `_yf_grid` (y-face) для \f(u\f),
"синяя" сетка `_xf_grid` (x-face) для \f(v\f)
\skip private
\skip _grid
\until _yf_grid
Далее заданы скалярные параметры: число Рейнольдса, шаги сетки и параметры алгоритма SIMPLE
\until _alpha_p

Далее следуют сеточные вектора, характеризующие текущее состояние решателя:
найденные на последней итерации давление и скорости.
\until _v;

Также определяется данные для решения системы уравнений для нахождения \f(p'\f) \f(\eqref{eq:ns2d_pstroke_slae}\f):
значения \f(d^u, d^u\f), а так же инициализированный решатель системы уравнений.
Поскольку используется постоянные шаги по времени, \f(d^u, d^v\f) являются скалярами.
\until _p_stroke_solver

Хранятся левая и правая части систем уравнений \f(\eqref{eq:ns2d_ustar_slae}, \eqref{eq:ns2d_vstar_slae}\f)
для определения пробных значений скорости и расчета невязки.
\until _rhs_v;

Указатели на классы, помогающие сохранять найденные вектора в vtk - формат.
Эти классы инициализируются только в случае, если пользователь указал на 
необходимость сохранения.
\until _writer_all;

### Инициализация решателя
\dontinclude{lineno} cavern_2d_simple_test.cpp

В секции инициализации конструктора
созаются сетки в единичном квадрате и переписываются параметры решения.
Далее в теле конструктора вычисляются значения
\f(d^u, d^v\f) по формулам \f(\eqref{eq:ns2d_du}, \eqref{eq:ns2d_dv}\f)
и собирается решатель для \f(p'\f). Как было указано ранее,
матрица системы \f(A^p\f) не меняется
с продвижением по итерациям, поэтому этот решатель можно собрать один раз
до начала счёта.
\skip Cavern2DSimpleWorker::Cavern2DSimpleWorker
\until }

Начальные значения устанавливаются через вызов функции `set_uvp`.
Эти начальные значения будут использоваться в качестве значений
с предыдущего итерационного слоя на первой итерации.

В функции происходит переписывание переданных векторов
в приватные поля класса.
\skip set_uvp(
\until _p

После этого данных в классе-решателе достаточно,
для сборки матриц \f(A^u, A^v\f) и правых частей
\f(b^u, b^v\f) для системы уравнений \f(\eqref{eq:ns2d_ustar_slae}, \eqref{eq:ns2d_vstar_slae}\f).
\until v_slae()

Если посмотреть на выражение для невязки \f(\eqref{eq:ns2d_residual}\f) убрав в нём крышки над переменными, то можно
убедится, что оно аппроксимируется в виде
\f{equation*}{
    r_u = \frac{1}{\tau}\left(A^u u - b^u\right).
\f}
Поэтому после сборки систем уравнений движения, можно вычислить невязку, характеризующую
отклонение установленного в этой процедуре решения от желаемого:
\until }

### Шаг итерации SIMPLE
\dontinclude{lineno} cavern_2d_simple_test.cpp
Осуществляется в процедуре
\skip double Cavern2DSimpleWorker::step(){
\until }
и представляет собой буквальное пошаговое следование алгоритму \ref simple-algo "SIMPLE".
В конце опять вызывается функция `set_uvp` для сборки матриц для следующей итерации
и подсчёта невязки на текущей итерации.

### Сборка системы уравнений для поправки давления
\dontinclude{lineno} cavern_2d_simple_test.cpp

Сборка системы уравнений \f(\eqref{eq:ns2d_pstroke_slae}\f)
осуществляется в процедуре
\skip void Cavern2DSimpleWorker::assemble_p_stroke_solver(){
\until void Cavern2DSimpleWorker::assemble_p_stroke_solver(){
Сборка происходит с использованием матрицы формата cfd::LodMatrix,
удобного для непоследовательной записи.
\until LodMatrix
Заполнение происходит в цикле по раздвоенным индексам \f(ij\f)
"чёрной" сетки для давления:
\until size_t i
Внутри цикла устанавливаются флаги, характеризующие граничный статус текущего узла
\until is_top
Вычисляется значение сквозного индекса по формуле \f(\eqref{eq:ns2d_kipjp}\f)
\until ind0
и значения коэффициентов в формулах \f(\eqref{eq:ns2d_ap}\f). Поскольку
сетка равномерная, эти значения не меняются для разных узлов
\until coef_y
Далее формулы \f(\eqref{eq:ns2d_ap}\f)
применяются для заполнения матриц
с учётом аппроксимированного граничного условия \f(\eqref{eq:ns2d_bc3}\f).
Так, запись
\until }
для всех неправых узлов с линейным индексом `ind0` вычисляет индекс 
узла, расположенного правее него с линейным индексом `ind1`,
добавляет слагаемое в диагональный (первое из уравнений \f(\eqref{eq:ns2d_ap}\f)) и
вычитает из недиагонального (четвёртое из уравнений \f(\eqref{eq:ns2d_ap}\f)) элемента
строки `ind0`.
Для правых узлов работает граничное условие \f(\eqref{eq:ns2d_ap}\f) и выполнять эту процедуру
не нужно.

После заполнения в матрицу вводится граничное условие \f(\eqref{eq:ns2d_bc4}\f)
\skip set_unit_row
\until set_unit_row

И матрица передаётся в решатель СЛАУ предварительно сконверованная в формат cfd::CsrMatrix
\until set_matrix

Правая часть собирается заново на каждой итерации по формуле \f(\eqref{eq:ns2d_bp}\f).
Её реализация представлена в функции
\skip Cavern2DSimpleWorker::compute_p_stroke
\until }
После сборки осуществляется установка граничного условия \f(\eqref{eq:ns2d_bc4}\f)
\until rhs[0]
и вызывается решатель СЛАУ
\until }

### Сборка системы уравнений для пробной скорости
\dontinclude{lineno} cavern_2d_simple_test.cpp

Сборка системы \f(\eqref{eq:ns2d_ustar_slae}\f) (как правой, так и левой частей) реализована
в функции
\skip Cavern2DSimpleWorker::assemble_u_slae
\until Cavern2DSimpleWorker::assemble_u_slae

Основной цикл идёт по негрничным узлам "красной" сетки,
в котором реализуются формулы \f(\eqref{eq:ns2d_au}\f)
\skip internal
\skip for (size_t
\until rhs
\until }

Как было отмечено в пункте \ref simple-bc,
граничные условия первого рода в этом уравнении
учитываются двумя разными способами:
узлы расположенные непосредственно на границе (нижней и верхней)
учитываются по схеме \f(\eqref{eq:ns2d_bc1}\f), которая реализована в цикле
\dontinclude{lineno} cavern_2d_simple_test.cpp
\skip 	for (size_t j=0; j< _grid.ny(); ++j){
\until rhs
\until rhs
\until }

А фиктивные узлы, возникающие при обработке
узлов расположенных в полушаге от границ (левой и правой),
обрабатываются по схеме \f(\eqref{eq:ns2d_bc2}\f).
Эта схема реализована в виде
препроцессинга алгоритма добавления элемента в матрицу в лямбда-функции
\dontinclude{lineno} cavern_2d_simple_test.cpp
\skip assemble_u_slae
\skip add_to_mat
\until };

Эта лямбда вызывается везде, где нужно добавить в строку `row_index`
и колонку, соответствующую узлу `ij_col`, значение `value`.
Она перехватывает ситуации с "фиктивным" узлом (\f(j=-1, j=n_y\f))
и применяет алгоритм \f(\eqref{eq:ns2d_bc2}\f).

# 5. (6.10)

## SIMPLER

TODO

## Нестационарное уравнение Навье-Стокса

TODO

## Завихренность и функция тока

Для несжимаемых течений (\f(\nabla\cdot\vec u = 0\f)) можно ввести векторный потенциал скорости:
\f{equation*}{
    \nabla\times\vec\Psi = \vec u
\f}

Также определим векторное поле завихренности как
\f{equation*}{
    \vec \Omega = \nabla \times \vec u
\f}

Компоненты этого вектора характеризуют вращательную составляющую скорости в
плоскостях, перпендикулярных соответствующим базисным векторам.
Например, компонента \f(\Omega_z\f) характеризует вращение в плоскости \f(xy\f).

Подставив векторный потенциал в выражение для завихренности, получим связь между двумя введёнными векторными полями
\f{equation*}{
    \vec \Omega = \nabla \times \left( \nabla \times \vec \Psi \right) = \nabla\left(\nabla\cdot\vec\Psi\right) - \nabla^2\vec\Psi.
\f}

Далее рассмотрим двумерные течения в декартовой системе координат. \f(z\f)-компонента
последнего выражения (с учётом \f(\partial/\partial z=0\f)) сократится до
\f{equation*}{
    \Omega_z = -\nabla^2\Psi_z
\f}
или, введя обозначения \f(\Omega_z = \omega\f), \f(\Psi_z = \psi\f):
\f{align}{
    \nonumber
     &\dfr{\psi}{y} = u, \\
    \label{eq:psiw_def}
    -&\dfr{\psi}{x} = v, \\
    \nonumber
     &\omega = \dfr{v}{x} - \dfr{u}{y}
\f}
и расписывая оператор Лапласа покоординатно
\f{equation}{
    \label{eq:psiw}
    -\left(\dfrq{\psi}{x} + \dfrq{\psi}{y}\right) = \omega.
\f}

Скалярное поле \f(\psi\f) называется функцией тока и его изолинии совпадают с линиями тока течения.
Действительно, введём прямоугольную систему координат \f((\vec n, \vec s)\f) вдоль линии тока
(вектор \f(\vec s\f) -- касательный к линии тока, \f(\vec n\f) -- нормаль) и 
перепишем определение \f(\eqref{eq:psiw_def}\f) в этой системе:
\f{align}{
    \label{eq:psi_bc}
     &\dfr{\psi}{s} = u_n, \\
    \nonumber
    -&\dfr{\psi}{n} = u_s.
\f}
По определению, вдоль линии тока \f(u_n = 0\f), отсюда получим \f(\psi = \rm{const}\f).

## Определение завихренности и функции тока на разнесённой сетке

Исходя из определения завихренности \f(\eqref{eq:psiw_def}\f), легко видеть
что аппроксимировать вторым порядком точности её проще всего на основной сетке \f(ij\f).
Для внутренних узлов можно записать:
\anchor omega_scheme_internal
\f{equation*}{
    \omega_{i,j} = \frac{v_{i+\tfrac12,j} - v_{i-\tfrac12,j}}{h_x}
                 - \frac{u_{i, j+\tfrac12} - u_{i, j-\tfrac12}}{h_y}.
\f}
Для граничных узлов возможно (при известных значениях скорости на границах) использовать направленные разности.
Например, для \f(i=0\f):
\anchor omega_scheme_bc
\f{equation*}{
    \omega_{0,j} = \frac{v_{\tfrac12,j} - v_{0,j}}{h_x/2}
                 - \frac{u_{i, j+\tfrac12} - u_{i, j-\tfrac12}}{h_y}.
\f}

Получив сеточный вектор для завихрённости \f({\omega}\f)
можно, исходя из \f(\eqref{eq:psiw}\f) записать разностную схему для 
определения функции тока во внутренних узлах сетки:
\anchor psi_scheme
\f{equation*}{
    \frac{-\psi_{i-1,j} + 2\psi_{i,j} - \psi_{i+1,j}}{h_x^2} +
    \frac{-\psi_{i,j-1} + 2\psi_{i,j} - \psi_{i,j+1}}{h_y^2} 
    = \omega_{i,j}.
\f}

На границах необходимо воспользоваться соотношениями \f(\eqref{eq:psi_bc}\f).
Из этих соотношениях функция тока вычисляется с точностью до константы (для каждой границы своей).
Одну из этих констант можно положить нулём.
Остальные вычисляются прямым интегрированием.
Например, рассмотрим течение в области высотой \f(Y\f) с непротекаемыми горизонтальными границами и двумя препятствиями.
\image html psi_bc.png width=800
Пусть скорость набегающего потока равна единице на всей входной границе.
На нижней границе положим \f(\psi_A=0\f).
На входной границе получим
\f{equation}{
    \dfr{\psi}{y} = 1 \; \hence \; \psi_{in}(y) = y + \psi_A = y.
\f}
Исходя из значения \f(\psi_{in}\f) на верхней границе можно записать
\f{equation*}{
    \psi_D = \psi_{in}(Y) = Y.
\f}

Для определения \f(\psi\f) на первом из двух препятствий рассмотрим траекторию \f(AB\f):
\f{equation*}{
    \dfr{\psi}{s} = u_n \; \hence \; \psi_B = \int_A^B u_n ds + \psi_A = Q_{AB},
\f}
где \f(s\f) - касательная к этой траектории, \f(n\f) -- нормаль к ней, \f(Q_{AB}\f) -- расход
жидкости поперёк траектории \f(AB\f). Вследствии несжимаемости можно
использовать любую из возможных положений точек \f(A\f), \f(B\f) на границах и любую из реализаций траектории.

Аналогично для второго тела можно записать
\f{equation*}{
    \psi_C = Q_{AC} = Q_{AB} + Q_{BC}.
\f}

# 6. (13.10)

## Оптимизация методов решения СЛАУ

В рассмотренном ранее методе расчёта двумерного течения вязкой несжимаемой жидкости
на каждой итерации необходимо решить три системы слиейных уравнений: \f(\eqref{eq:ns2d_ustar_slae}\f),
\f(\eqref{eq:ns2d_vstar_slae}\f), \f(\eqref{eq:ns2d_pstroke_slae}\f).
Причём левые части первых двух систем уравнений меняются от итерации к итерации, в то
время как левая часть третьей остаётся постоянной.

Последнее обстоятельство накладывает некоторые ограничения на
оптимальный выбор решателя сеточных систем линейных уравнений.

В частности, для систем
\f(\eqref{eq:ns2d_ustar_slae}\f),
\f(\eqref{eq:ns2d_vstar_slae}\f) не следует использовать решатели
с большим временем инициализации (этап инициализации требуется решателю
на этапе задания матрицы левой части).

Для системы
\f(\eqref{eq:ns2d_pstroke_slae}\f), напротив,
можно использовать решатели с дорогой инициализацией, так как
она проводится один раз до начала итераций SIMPLE.

В рассмотренных ранее примерах использовался алгебраический
многосеточный итерационный решатель, который имеет существенное время
инициализации. Ниже рассмотрим некоторые более простые итерационные способы решения систем
уравнений, которые, хотя и имеют значительно худшую сходимость, но не требуют дорогой инициализации.

Поскольку итерации для решения СЛАУ являются внутренними относительно SIMPLE-итераций,
то при использовании этих решателей не требуется доводить их до полной сходимости.
Достаточно сделать один-два шага. А полную сходимость можно "переложить" на вышестоящий
итерационный процесс.

### Метод Якоби {#SLAE-Jacobi}

Будем рассматривать систему уравнений вида
\f{equation*}{
    \sum_{j=0}^{j<N} A_{ij} u_j = r_i, \quad i = \overline{0, N-1}
\f}
относительно неизвестного сеточного вектора \f(\{u\}\f).

В классическом виде алгоритм Якоби формулируется в виде
\f{equation*}{
    \hat u_i = \frac{1}{A_{ii}}\left(r_i - \sum_{j\neq i} A_{ij}{u_j}\right)
\f}

Произведём некоторые преобразования
\f{align*}{
    \hat u_i &= \frac{1}{A_{ii}}\left(r_i - \sum_{j} A_{ij}{u_j} + A_{ii}u_i\right) \\
             &= u_i + \frac{1}{A_{ii}}\left(r_i - \sum_{j} A_{ij}{u_j}\right)
\f}

Таким образом, программировать итерацию этого алгоритма, обновляющую значения массива \f(\{u\}\f), можно в виде
\f{align*}{
    &\hat u = u; \\
    &\textbf{for } i=\overline{0, N-1} \\ 
    &\quad \hat u_i \mathrel{{+}{=}} \frac{1}{A_{ii}}\left(r_i - \sum_{j=0}^{j<N} A_{ij}{u_j}\right)\\
    &\textbf{endfor} \\
    & u = \hat u; \\
\f}


### Метод Зейделя {#SLAE-Seidel}
Формулируется в виде
\f{equation*}{
    \hat u_i = \frac{1}{A_{ii}}\left(r_i - \sum_{j<i} A_{ij}{\hat u_j} - \sum_{j>i} A_{ij}{u_j} \right).
\f}

Поскольку этот метод неявный относительно уже найденных на итерации значений, то в отличии от метода Якоби этот алгоритм не требует создания временного массива \f(\hat u\f)
при программировании. Псевдокод для реализации итерации этого метода можно записать как

\f{align*}{
    &\textbf{for } i=\overline{0, N-1} \\ 
    &\quad u_i \mathrel{{+}{=}} \frac{1}{A_{ii}}\left(r_i - \sum_{j=0}^{j<N} A_{ij}{u_j}\right)\\
    &\textbf{endfor}
\f}


### Метод последовательных верхних релаксаций (SOR) {#SLAE-SOR}
Этот метод основан на добавлении к решению результатов итераций Зейделя с
коэффициентом \f(\omega > 1\f). То есть он изменияет решение по тому же
принципу, что и метод Зейделя, но искуственно увеличивает эту добавку.

Формулируется этот метод в виде
\f{equation*}{
    \hat u_i = (1-\omega) u_i + \frac{\omega}{A_{ii}}\left(r_i - \sum_{j<i} A_{ij}{\hat u_j} - \sum_{j>i} A_{ij}{u_j} \right).
\f}
Для устойчивости метода необходимо \f(\omega < 2\f). Обычно используют \f(\omega=1.95\f).

Итерация этого метода по аналогии с методом Зейделя может быть запрограммирована в виде

\f{align*}{
    &\textbf{for } i=\overline{0, N-1} \\ 
    &\quad u_i \mathrel{{+}{=}} \frac{\omega}{A_{ii}}\left(r_i - \sum_{j=0}^{j<N} A_{ij}{u_j}\right)\\
    &\textbf{endfor}
\f}


### Формат хранения разреженных матриц CSR
При реализации решателей систем сеточных уравнений важно учитывать
разреженный характрер используемых в левой части. То есть избегать
хранения и ненужных операций с нулевыми элементами матрицы.

Хотя рассмотренные ранее алогритмы конечноразностных аппроксимаций на структурированных сетках
давали трёх- (для одномерных задач) или пятидиагональную (для двумерных) сеточную матрицу,
здесь будем рассматривать общие форматы хранения, не привязанные к конкретному шаблону.

Любой общий
формат хранения должен хранить
информацию о шаблоне матрице (адресах ненулевых элементов)
и значениях матричных коэффициентов в этом шаблоне.

В CSR (Compressed sparse rows) формате
все ненулевые элементы хранятся в линейном массиве `vals`.
А шаблон матрицы -- в двух массивах
- массиве колонок cols -- значений колонок для соответствующих ему значений из массива vals,
- массиве адресов addr -- индексах массива vals, с которых начинается описание соответствующей строки.
В конце массива `addr` добавляется общая длина массива `vals`.

Таким образом, длины массивов `vals`, `cols` равны количеству ненулевых элементов матрицы,
а длина массива `addr` равна количеству строк в матрице плюс один.

Для облегчения процедур поиска описание каждой строки должно идти последовательно
с увеличением индекса колонки.

Для примера рассмотрим следующую матрицу
\f{equation*}{
\left(
\begin{array}{cccc}
1.0 & 0 & 0 & 2.0 \\
0 & 3.0 & 4.0 & 5.0 \\
0 & 0 & 6.0 & 0 \\
0 & 7.0 & 0 & 8.0 \\
\end{array}
\right)
\f}

Массивы, описывающие матрицу в формате CSR примут вид

\f{equation*}{
\begin{array}{r|l|l|l|l}
      & row=0     & row=1          & row=2& row=3&\\
\hline
vals= & 1.0, 2.0, & 3.0, 4.0, 5.0, & 6.0, & 7.0, 8.0 &\\
\hline
cols= & 0,\phantom{.0} 3,\phantom{.0}      & 1,\phantom{.0}2,\phantom{.0}3,\phantom{.0}          & 2,\phantom{.0}   & 1,\phantom{.0} 3     &\\
\hline
addr= & 0,        & 2,             & 5,   & 6,       & 8 \\
\hline
\end{array}
\f}

Рассмотрим реализацию базовых алгоритмов для матриц, заданных в этом формате.

Пусть матрица задана следующими массивами:
@code{cpp}
std::vector<double> vals; // массив значений
std::vector<size_t> cols; // массив столбцов
std::vector<size_t> addr; // массив адресов
@endcode

Число строк в матрице:
@code{cpp}
size_t nrows = addr.size()-1;
@endcode

Число элементов в шаблоне (ненулевых элементов)
@code{cpp}
size_t n_nonzeros = vals.size();
@endcode

Число ненулевых элементов в заданной строке `irow`
@code{cpp}
size_t nonzeros_in_row = addr[irow+1] - addr[irow];
@endcode

Умножение матрицы на вектор `v` (длина этого вектора должна быть равна числу строк в матрице).
Здесь реализуется суммирование вида
\f{equation*}{
    r_i = \sum_{j=0}^{j<N} A_{ij} v_j,
\f}
при этом избегаются лишние операции с нулями
@code{cpp}
size_t nrows = addr.size() - 1;                           // число строк в матрице и длина вектора vec
std::vector<double> r(nrows, 0);                          // массив ответов. Инициализируем нулями
for (size_t irow=0; irow < nrows; ++irow){                // цикл по строкам
    for (size_t a = addr[irow]; a < addr[irow+1]; ++a){   // цикл по ненулевым элементам строки irow
        size_t icol = cols[a];                            // получаем индекс колонки
        double val = vals[a];                             // значение матрицы на позиции [irow, icol]
        r[irow] += val * v[icol];                         // добавляем к ответу
    }
}
@endcode


Поиск значения элемента матрицы по адресу [irow, icol] с учётом локально сортированного вектора cols
@code{cpp}
using iter_t = std::vector<size_t>::const_iterator;
// указатели на начало и конец описания строки в массиве cols
iter_t it_start = cols.begin() + a[irow];
iter_t it_end = cols.begin() + a[irow+1];
// поиск значения icol в отсортированной последовательности [it_start, it_end)
iter_t fnd = std::lower_bound(it_start, it_end, icol);
if (fnd != it_end && *fnd == icol){
    // если нашли элемент icol, то определяем индекс найденного элемента в массиве icol
	size_t a = fnd - cols.begin();
    // и возвращаем значение из vals по этому индексу
	return vals[a];
}
// если не нашли, значит элемент [irow, icol] находится вне шаблона. Возвращаем 0
return 0;
@endcode

## Задача об обтекании препятствия

TODO

## Баланс сил в задачах о внешнем обтекании. Коэффициенты сил

TODO
