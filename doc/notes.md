@page notes Краткое содержание лекций

# 1. Введение (02.09)
Общее описание инфраструктуры проекта для работы по курсу лекций.

# 2. Уравнение Пуассона (09.09)

Решение одномерной задачи Пуассона с граничными условиями первого рода методом конечных разностей.
Понятие о точности аппроксимации сеточной схемы.

## Постановка задачи
Рассматривается одномерное дифференциальное уравнение вида
\f{equation}{
    \label{eq:poisson1d}
    -\ddfrq{u}{x} = f(x)
\f}
в области \f$x\in[a,b]\f$ с граничными условиями первого рода
\f{equation}{
	\label{eq:poisson1d_bc}
	\begin{cases}
        u(a)=u_a,\\[5pt]
        u(b)=u_b.\\
	\end{cases}
\f}
Необходимо:
- Запрограммировать расчётную схему для численного решения этого уравнения методом конечных разностей
  на сетке с постоянным шагом,
- С помощью вычислительных экспериментов подтвердить порядок аппроксимации расчётной схемы.

## Метод решения

### Нахождение численного решения {#poisson1d_fdm}

В области решения \f$[a,b]\f$ введём равномерную сетку из \f$N\f$ ячеек.
Шаг сетки будет равен \f$h=(b-a)/N\f$.
Узлы сетки запишем в виде сеточного вектора \f$\{x_i\}\f$ длины \f$N+1\f$, где \f$i=\overline{0,N}\f$.
Определим сеточный вектор \f$\{u_i\}\f$ неизвестных, элементы которого определяют значение искомого численного решения в \f$i\f$-ом узле сетки. 

Разностная схема второго порядка для уравнения \f(\eqref{eq:poisson1d}\f) имеет вид
\f{equation}{
    \label{eq:poisson1d_fdm}
    \frac{-u_{i-1} + 2u_{i} - u_{i+1}}{h^2} = f_i, \qquad i=\overline{1,N-1}.
\f}
Здесь \f$\{f_i\}\f$ -- известный сеточный вектор, определяемый через известную
аналитическую функцию \f$f(x)\f$ в правой части уравнения \f(\eqref{eq:poisson1d}\f) как
\f{equation}{
    \label{eq:poisson1d_fdm2}
    f_i = f(x_i).
\f}

Аппроксимация граничных условий \f(\eqref{eq:poisson1d_bc}\f) первого рода даёт дополнительные 
сеточные уравнения для граничных узлов
\f{equation}{
    \label{eq:poisson1d_fdm_bc}
    \begin{array}{ll}
        u_0 = u_a,\\
        u_N = u_b
    \end{array}
\f}

Линейные уравнения \f(\eqref{eq:poisson1d_fdm}, \eqref{eq:poisson1d_fdm_bc}\f)
составляют систему вида

\f{equation*}{
    \sum_{j=0}^{N} A_{ij}\,u_j = b_i, \qquad i=\overline{0,N}
\f}
с матричными коэффициентами
\f{equation}{
    \label{eq:poisson1d_fdm_lhs}
    A_{ij} = \begin{cases}
        1,      &\quad i=0, \, j=0; \\
        2/h^2,  &\quad i=\overline{1,N-1}, \, j=i;\\
        -1/h^2, &\quad i=\overline{1,N-1}, \, j=i-1;\\
        -1/h^2, &\quad i=\overline{1,N-1}, \, j=i+1;\\
        1,      &\quad i=N, \, j=N; \\
        0,      &\quad {\text иначе}.
    \end{cases}
\f}
и правой частью
\f{equation}{
    \label{eq:poisson1d_fdm_rhs}
    b_i = \begin{cases}
        u_a,   &\quad i=0;\\
        u_b,   &\quad i=N;\\
        f_i,   &\quad i=\overline{1,N-1}.
    \end{cases}
\f}
Искомый вектор находится путём решения этой системы.

### Практическое определения порядка аппроксимации

Порядок аппрокцимации показывает скорость
приближения численного решения к точному с уменьшением сетки.
Поэтому для подтверждения порядка необходимо
- Знать точное решение,
- Уметь вычислять функционал (норму, \f(||\cdot||\f)), характеризующий отклонение точного решения от численного,
- Сделать несколько расчётов на сетках с разной \f(N\f)  и заполнить таблицу \f(||\{u_i - u^e(x_i)\}||(N)\f),
- На основе этой таблицы построить график в логарифмических осях и по углу наклона кривой сделать вывод о порядке аппроксимации.

Выберем произвольную функцию \f$u^e\f$ (достаточно сильно изменяющуюся на целевом отрезке \f$[a,b]\f$).

Далее путём прямого вычисления определим параметры задачи \f$f\f$, \f$u_a\f$, \f$u_b\f$ такие,
для которых функция \f$u^e\f$ является точным решением задачи \f(\eqref{eq:poisson1d}\f), \f(\eqref{eq:poisson1d_bc}\f).

Зададимся числом разбиений \f$N\f$ и решим задачу для выбранным параметров.
В результате определим сеточный вектор численного решения \f$\{u_i\}\f$.

В качестве нормы выберем стандартное отклонение. В интегральном виде для многомерной функции \f$y(\vec x)\f$
в области \f$\vec x\in D\f$ оно имеет вид
\f{equation*}{
    ||y(\vec x)||_2 = \sqrt{\frac{1}{|D|}\int_{D} y(\vec x)^2 \, d\vec x}.
\f}
Упрощая до одномерного случая
\f{equation*}{
    ||y(x)||_2 = \sqrt{\frac{1}{b-a}\int_{a}^{b} y(x)^2 \, dx}.
\f}

Вычислим этот интеграл численно на введённой ранее равномерной сетке \f$\{x_i\}\f$:
\f{equation*}{
    ||\{y_i\}||_2 = \sqrt{\frac{1}{b-a}\sum_{i=0}^{N} w_i y_i^2},
\f}
где \f$\{w_i\}\f$ -- вес (или "площадь влияния") \f$i\f$-ого узла:
\f{equation*}{
    w_i = \begin{cases}
        h/2, &\quad i=0, N;\\
        h, &\quad i=\overline{1,N-1},
    \end{cases}
\f}
такая что
\f{equation*}{
    \sum_{i=0}^{N} w_i = b-a.
\f}

Окончательно среднеквадратичная норма отклонения численного решения от точного запишется в виде
\f{equation}{
    \label{eq:poisson1d_fdm_norm}
    ||\{u_i - u^e(x_i)\}||_2 = \sqrt{\frac{1}{b-a}\sum_{i=0}^{N} w_i \left(u_i - u^e_i\right)^2}.
\f}

## Программная реализация {#test_poisson1}
\dontinclude{lineno} poisson_solve_test.cpp

Тестовая программа для решения одномерного уравнения Пуассона 
реализована в фале poisson_solve_test.cpp.

В качестве аналитической тестовой функции  используется
\f{equation*}{
    u^e = \sin(10 x^2)
\f}
на отрезке \f$x\in[0,1]\f$.

### Функция верхнего уровня
объявлена как
\skip TEST_CASE("Poisson 1D solver", "[poisson1]"){
\until TEST_CASE
В программе в цикле по набору разбиений \c n_cells
\skip for (size_t n_cells
\until for (size_t n_cells
создаётся решатель для тестовой задачи, использующий заданное число ячеек
\skip worker
\until worker
вычисляется среднеквадратичная норма отклонения численного решения от точного
\skip n2
\until n2
полученное численное решение (вместе с точным) сохраняется в vtk файле "poisson1_ncells={10,20,...}.vtk"
\skip save_vtk
\until save_vtk
а полученная норма печатается в консоль напротив количества ячеек
\skip cout
\until cout

В результате работы программы в консоли должна отобразиться таблица вида
@code
--- cfd24_test [poisson1] ---
10 0.179124
20 0.0407822
50 0.00634718
100 0.00158055
200 0.000394747
500 6.31421e-05
1000 1.57849e-05
@endcode
где первый столбец -- это количество ячеек, а второй -- полученная для этого количества ячеек норма.
Нарисовав график этой таблицы в логарифмических осях подтвердим второй порядок аппроксимации.

\image html poisson1_appr.png width=800

Открыв один из cохранённых в процессе работы файлов vtk poisson1_ncells={}.vtk в паравью
можно посмотреть полученные графики. В файле представлены как точное "exact", так и численное решение "numerical".
Инструкции о настройке отображения одномерных графиков смотри \ref paraview-1d "здесь".

\image html poisson1_graph.png width=600

### Детали реализации
Основная работа по решению задачи проводится в классе \c TestPoisson1Worker.

В его конструкторе происходит инициализация сетки (приватного поля класса) на отрезке \f([0, 1]\f) с заданным разбиением \c n_cells:
\dontinclude{lineno} poisson_solve_test.cpp
\skip TestPoisson1Worker(
\until TestPoisson1Worker(

В методе \c solve() производится чиленное решения задачи и вычисления нормы.
Для этого последовательно
1. Строится матрица левой части и вектор правой части определяющей системы уравнений.
   Матрицы хранятся в разреженном формате CSR, удобном для последовательного чтения.
2. Вызывается решатель СЛАУ. Решение записывается в приватное поле класса \c u.
3. Вызывается функция вычисления нормы.

\skip double solve()
\until }

Функции нижнего уровня (используемые в методе \c solve):
- Сборка левой части СЛАУ. Реализует формулу \f(\eqref{eq:poisson1d_fdm_lhs}\f).
  Для заполнения матрицы используется формат cfd::LodMatrix, удобный для непоследовательной записи, который в конце конвертируется CSR.
  \skip approximate_lhs(
  \until return
  \until }

- Сборка правой части СЛАУ. Реализует формулу \f(\eqref{eq:poisson1d_fdm_rhs}\f).
  \skip approximate_rhs(
  \until return
  \until }

- Вычисление нормы. Реализует формулу \f(\eqref{eq:poisson1d_fdm_norm}\f).
  \skip double compute_norm2
  \until return
  \until }

# 3. Двухслойные схемы для нестационарных уравнений (16.09)

## Определение

Рассмотрим дифференциальное уравнение вида

\f{equation}{
    \label{eq:nonstat_common}
    \dfr{u}{t} + Lu = f,
\f}
где \f(L\f) -- произвольный пространственный дифференциальный оператор.
При использовании двухслойной схемы аппроксимации производная по времени записывается в
виде конечной разности с шагом \f(\tau\f), которая может приближать производную
в одном из трёх моментов времени:

\f{equation}{
    \label{eq:nonstat_dt_appr}
    \begin{array}{lll}
        \dfrac{u(t+\tau) - u(t)}{\tau} = 
            & \quad \left.\ddfr{u}{t}\right|_{t}
            & + o(\tau)
            & -\text{ разность вперёд};\\[5pt]
        \phantom{a}
            & \quad \left.\ddfr{u}{t}\right|_{t+\tau}
            & + o(\tau)
            & -\text{ разность назад};\\[5pt]
        \phantom{a}
            & \quad \left.\ddfr{u}{t}\right|_{t+\frac{\tau}{2}}
            & + o(\tau^2)
            & -\text{ симметричная разность.}
    \end{array}
\f}

Момент времени \f(t\f) будем называть текущим временн<strong>ы</strong>м слоем,
момент \f(t + \tau\f) -- следующим,
а момент \f(t+\tau/2\f) -- промежуточным.
Считается, что
значение функции на текущий момент времени \f(u(t)\f) известно, а
значение на следующий момент \f(u(t+\tau)\f) подлежит определению.

### Явная схема

При использовании разности назад уравнение \f(\eqref{eq:nonstat_common}\f)
в полудискретизованном (то есть дискретизованном только по времени, но не по пространству) виде
запишется как
\f{equation*}{
    \frac{u(x, t+\tau) - u(x)}{\tau} + L u(x, t) = f(x, t)
\f}
или, после переноса всех известных слагаемых вправо
\f{equation}{
    \label{eq:nonstat_explicit}
    u(x, t+\tau) = \left(E - \tau L\right) u(x, t) + \tau f(x, t).
\f}
Здесь \f(E\f) -- единичный оператор.
Схема \f(\eqref{eq:nonstat_explicit}\f) называется явной схемой
и имеет первый порядок точности.

### Неявная схема

Выбрав разность назад из выражения \f(\eqref{eq:nonstat_dt_appr}\f)
полудискретизованная схема для уравнения \f(\eqref{eq:nonstat_common}\f) примет вид
\f{equation*}{
    \frac{u(x, t+\tau) - u(x)}{\tau} + L u(x, t+\tau) = f(x, t+\tau).
\f}
В результате преобразования получим неявную схему первого порядка точности
\f{equation}{
    \label{eq:nonstat_implicit}
    \left(E+\tau L\right) u(x, t+\tau) = u(x, t) + \tau f(x, t + \tau).
\f}

### Схема Кранка--Николсон

Подставим симметричную разность из \f(\eqref{eq:nonstat_dt_appr}\f)
в уравнение \f(\eqref{eq:nonstat_common}\f). Формально получим
\f{equation*}{
    \frac{u(x, t+\tau) - u(x)}{\tau} + L u(x, t+\frac{\tau}{2}) = f(x, t+\frac{\tau}{2}).
\f}

Для определения выражения функций на промежуточном временном слое
распишем значение \f$u\f$ на текущем и следующем слоях в ряд Тейлора
относительно значения на момент \f$t+\tau/2\f$:
\f{align*}{
    u\left(t\right)      &= u\left(t+\frac{\tau}{2}\right) - \left.\frac{\tau}{2}\dfr{u}{t}\right|_{t+\frac{\tau}{2}} + o(\tau^2)\\
    u\left(t+\tau\right) &= u\left(t+\frac{\tau}{2}\right) + \left.\frac{\tau}{2}\dfr{u}{t}\right|_{t+\frac{\tau}{2}} + o(\tau^2)
\f}
Взяв полусумму этих выражений получим аппроксимацию функции на промежуточном слое:
\f{equation}{
    \label{eq:nonstat_cn_appr}
    u\left(x, t + \frac{\tau}{2}\right) = \frac12u\left(x, t\right) + \frac12u\left(x, t+\tau\right) + o(\tau^2)
\f}
Аналогичная запись справедлива и для свободного члена \f$f\f$.
Если оператор \f(L\f) -- нестационарный или нелининый, то аппроксимацию \f(\eqref{eq:nonstat_cn_appr}\f)
следует записывать для всего выражения \f(Lu\f):
\f{equation*}{
    \left(Lu\right)_{t+\frac{\tau}{2}} = \frac12\left(Lu\right)_{t} + \frac12\left(Lu\right)_{t+\tau} + o(\tau^2)
\f}


С учётом \f(\eqref{eq:nonstat_cn_appr}\f) симметричная разностная схема
запишется как
\f{equation*}{
    \frac{u(x, t+\tau) - u(x)}{\tau} + \frac12L u(x, t) + \frac12 L u(x, t + \tau) = \frac12 f(x, t) + \frac12 f(x, t+\tau)
\f}
или
\f{equation}{
    \label{eq:nonstat_cn}
    \left(E+\frac{\tau}{2} L\right) u(x, t+\tau) = \left(E - \frac{\tau}{2} L\right) u(x, t) + \frac{\tau}{2} \left(f(x, t) + f(x, t + \tau)\right).
\f}
Такая схема называется схемой Кранка--Николсон и имеет второй порядок аппроксимации по времени.

В случае, если оператор \f(L\f) зависит от времени, то
в левой части схемы \f(\eqref{eq:nonstat_cn}\f) его нужно
брать на следующем временном слое, а в правой -- на текущем.

### Обобщённая двухслойная схема

Выражения
\f(\eqref{eq:nonstat_explicit}\f),
\f(\eqref{eq:nonstat_implicit}\f),
\f(\eqref{eq:nonstat_cn}\f)
можно записать в обобщённой форме
\f{equation}{
    \label{eq:nonstat_theta}
    \left(E+\theta\tau L\right) u(x, t+\tau) = \left(E + \left(\theta - 1\right)\tau L\right) u(x, t) + \left(1 - \theta\right) f(x, t) + \theta f(x, t + \tau).
\f}
Коэффициент \f(\theta\f) -- степень неявности схемы:
- \f(\theta = 0\f) -- явная схема \f(\eqref{eq:nonstat_explicit}\f),
- \f(\theta = 1\f) -- полностью неявная схема \f(\eqref{eq:nonstat_implicit}\f),
- \f(\theta = 1/2\f) -- схема Кранка--Николсон \f(\eqref{eq:nonstat_cn}\f).

Отметим, что только при \f(\theta = 1/2\f) схема \f(\eqref{eq:nonstat_theta}\f) имеет второй порядок точности по времени.
Для других значений (в том числе промежуточных) схема будет иметь ошибку первого порядка \f(o(\tau)\f).

## Дискретизация по времени как итерационный процесс

### Двухслойный итерационный процесс

Простой двухслойный итерационный процесс определяется как
\f{equation}{
    \label{eq:nonstat_common_iter}
    u^{n+1} = A u^{n} + b,
\f}
где \f(n\f) -- индекс итерационного слоя,
\f(A\f) -- оператор преобразования,
\f(b\f) -- свободный член.

Определение значения функции на следующий момент времени \f(u(t+\tau)\f) 
по двухслойной схеме \f(\eqref{eq:nonstat_theta}\f) можно представить как простой итерационный процесс \f(\eqref{eq:nonstat_common_iter}\f), где
\f{align*}{
    A &= \left(E + \theta \tau L \right)^{-1} \left(E + (\theta - 1) \tau L \right), \\\\
    b &= \left(E + \theta \tau L \right)^{-1} \left( \theta f\left(x, t + \tau\right) + \left(1 - \theta\right) f\left(x, t\right) \right).
\f}

Итерационный процесс называется сходящимся, если
\f{equation*}{
    \lim_{n=\infty} \left\lVert u^{n+1} - u^{n} \right\rVert = 0.
\f}

### Устойчивость итерационного процесса {#ScalarIter}

Рассмотрим два простых итерационных процесса,
имеющих на нулевом слое значение \f(u^0 = 1\f):
\f{align*}{
    {\rm (I)}:\quad  &u^{n+1} = 2 u^{n} - 1, \\
    {\rm (II)} :\quad  &u^{n+1} = 0.5 u^{n} + 0.5.
\f}
Оба этих процесса при выбранном начальном приближении, очевидно, сходятся.
На каждой итерации справделиво \f(u^n = 1\f).
Возмутим начальное условие: пусть
\f{equation*}{
    u^0 = 1 + \eps,
\f}
и проведём итерации.
\f{equation*}{
    \begin{array}{c|c|c}
        & {\rm (I)}  &  {\rm (II)} \\ 
        \hline
        u^1 & 1 + 2\eps & 1 + \dfrac{\eps}{2} \\ 
        \hline
        u^2 & 1 + 4\eps & 1 + \dfrac{\eps}{4} \\ 
        \hline
        u^3 & 1 + 8\eps & 1 + \dfrac{\eps}{8} \\ 
        \hline
        ... & & \\
        \hline
        u^\infty & \infty & 1 \\ 
    \end{array}
\f}

Видно, что процесс \f(\rm (I)\f) теряет сходимость и стремится к бесконечности,
в то время, как процесс \f(\rm (II)\f) сохраняет свои свойства.

Свойство итерационных процессов уменьшать малые возмущения называется устойчивостью.
В примере выше процесс \f(\rm (I)\f) является неустойчивым, а процесс \f(\rm (II)\f) -- устойчивым.

Нетрудно видеть, что для рассматриваемого скалярного итерационного процесса,
условие устойчивости запишется в виде \f(|A| \leq 1\f).

### Источники возмущений

На практике возникновение возмущений в решениях неизбежно:
они могут быть следствием ошибок дискретизации функций и операторов,
погрешностей решения СЛАУ, ошибок при проведении арифметических
операций на числах с плавающей точкой и т.д.
Поэтому любой итерационный процесс, используемый для решений
математических задач, должен быть устойчив.

Возникновение непреднамеренных ошибок вследствии компьютерного округления можно проиллюстрировать на примере
программы, в которой рассматривается сходящийся для любого начального условия, но неустойчивый итерационный процесс
\f{equation*}{
    u^{n+1} = 10 u^{n} - 9 u^{0}.
\f}
\code{cpp}
double u0 = 0.625;
double u = u0;
for (int i=0; i<1000; ++i){
    u = 10*u - 9*u0;
}
std::cout << u << std::endl;
\endcode

Если начальное значение может быть точно представлено в
числах с плавающей точкой (путём конечной суммы степеней двойки),
то арифметическая ошибка не возникает.
Так, представленный выше код на выходе печатает ожидаемое \f(u=0.625\f).
Потому что начальное приближение может быть разложено как \f(u^0 = 2^{-1} + 2^{-3}\f).

Однако, если заменить начальное приближение на любое число,
которое не может быть записано точно во floating-point формате,
то процесс быстро уходит в бесконечность.
Например, для \f(u^0 = 0.626\f) бесконечные (непредставимые в машинном формате) значения
появляются на 324-ой итерации,
а при переключении на работу в числах одинарной точности `float` -- уже на 46-ой.

## Методы исследования устойчивости расчётных схем

### Матричный метод

Итерационные процессы, возникающие при численном решении
дифференциальных уравнений сеточными методами, имеют матричную природу.
То есть оператор преобразования \f(A\f) в выражении \f(\eqref{eq:nonstat_common_iter}\f) -- это матрица,
а функции \f(u\f) и \f(b\f) -- векторы-столбцы.

Как было показано выше, условием устойчивости скалярного итерационного процесса является неравенство \f(|A| \leq 1\f).
Аналогом этого условия для матричного процесса является ограничение на спектральный радиус \f(S(A)\f):
\f{equation}{
    \label{eq:nonstat_spectral_radius}
    S(A) = \max_j{ | \lambda_j | } \leq 1,
\f}
где \f(\lambda_j\f) -- собственные числа матрицы \f(A\f).

Для некоторых видов матриц, возникающих при аппроксимации простейших дифференциальных уравнений,
собственные числа известны.

#### Явная схема для нестационарного уравнения диффузии {#NonstatExpDiff}

Например, рассмотрим одномерное нестационарное уравнение диффузии с граничными условиями первого рода
\f{align*}{
    &\dfr{u}{t} = k\dfrq{u}{x},\\[5pt]
    &u(x, 0) = u_0(x),\\[5pt]
    &u(x_a, t) = u_a,\\[5pt]
    &u(x_b, t) = u_b.\\
\f}
Используем явную дискретизацию по времени и аппроксимацию второго порядка по пространству.
Тогда разностная схема запишется в виде:
\f{equation}{
    \label{eq:nonstat_explicit_diff}
    \hat u_i = u_i + \gamma (u_{i-1} - 2 u_i + u_{i+1}), \quad i = \overline{1, N-1},
\f}
где введено обозначение для значения функции на следующем временном слое \f(\hat u = u(t+\tau)\f) и \f(\gamma = \tau k / h^2 \f).
В матричном виде схема имеет вид
\f{equation*}{
    \hat u = A u, \quad
    A = \left(
        \begin{array}{cccccc}
            1      & 0          &           &            &           &        \\
            \gamma & 1-2\gamma  & \gamma    &            &           &        \\
                   & \gamma     & 1-2\gamma & \gamma     &           &        \\
                   &            & \ddots    & \ddots     & \ddots    &        \\
                   &            &           & \gamma     & 1-2\gamma & \gamma \\ 
                   &            &           &            & 0         & 1      
        \end{array}
    \right).
\f}
Первая и последняя строки этой матрицы -- следствие учёта граничных условий первого рода.

Собственные числа для полученной трёхдиагональной матрицы преобразования в правой части имеют вид
\f{equation*}{
    \lambda_j = 1 - 4\gamma\sin^2\left(\frac{j\pi}{2 N}\right), \quad j = \overline{1, N-1}
\f}
Тогда, исходя из выражения \f(\eqref{eq:nonstat_spectral_radius}\f), запишем условие устойчивости
для явной схемы \f(\eqref{eq:nonstat_explicit_diff}\f)
\f{equation*}{
    \gamma \leq \frac12
\f}

#### Неявная схема для нестационарного уравнения диффузии {#NonstatImpDiff}

Аналогично, рассмотрим неявную схему
\f{equation}{
    \label{eq:nonstat_implicit_diff}
    \hat u_i - \gamma (\hat u_{i-1} - 2 \hat u_i + \hat u_{i+1}) = u_i, \quad i = \overline{1, N-1},
\f}
В матричном виде
\f{equation*}{
    \hat u = A^{-1} u, \quad
    A = \left(
        \begin{array}{cccccc}
            1      & 0          &           &            &           &        \\
            -\gamma& 1+2\gamma  &-\gamma    &            &           &        \\
                   &-\gamma     & 1+2\gamma &-\gamma     &           &        \\
                   &            & \ddots    & \ddots     & \ddots    &        \\
                   &            &           &-\gamma     & 1+2\gamma &-\gamma \\ 
                   &            &           &            & 0         & 1      
        \end{array}
    \right).
\f}

Собственные числа такой матрицы имеют вид
\f{equation*}{
    \lambda_j = 1 + 4\gamma\sin^2\left(\frac{j\pi}{2 N}\right), \quad j = \overline{1, N-1}
\f}
Поскольку в правой части итерационного процесса используется матрица, обратная к \f(A\f),
а собственные числа обратных матриц равны \f(1/\lambda_j\f), то условие устойчивости
примет вид
\f{equation*}{
    \lambda_j \geq 1.
\f}
Очевидно, что оно выполняется всегда. Поэтому неявная схема \f(\eqref{eq:nonstat_implicit_diff}\f) безусловно устойчива.

### Метод дискретных возмущений

Метод дискретных возмущений заключается
в использовании в качестве начального приближения
нулевого вектора, с возмущением \f(\eps\f)
в одном из узлов:
\f{equation*}{
    u^0 = \left(
        \begin{array}{c}
            0\\
            \vdots\\
            0\\
            \eps\\
            0\\
            \vdots\\
            0
        \end{array}
        \right)
\f}
и дальнейшем анализом
распространения этого возмущения с прохождением
по временным слоям.
Во многом этот метод аналогичен тому алгоритму,
по которому мы иллюстрировали устойчивость
\ref ScalarIter "простейшего скалярного итерационного процесса".

#### Явная схема против потока для уравнения переноса {#NonstatExpTran}

Для иллюстрации рассмотрим одномерное уравнение переноса
\f{equation}{
    \label{eq:nonstat_transport}
    \dfr{u}{t} + V\dfr{u}{x} = 0
\f}
и явную противопоточную схему для него (при условии \f(V > 0\f))
\f{equation}{
    \label{eq:nonstat_explicit_transport}
    \hat u_i = u_i - C \left(u_i - u_{i-1}\right),
\f}
где число Куранта определено как \f(C = \tau V /h \f).

Пусть \f(u_i = \eps\f). Тогда
\f{align*}{
    & \hat u_i = (1 - C) \eps & \hence & \; 0 \leq C \leq 2,  \\[5pt]
    & \hat u_{i+1} = C \eps   & \hence & \; -1 \leq C \leq 1.
\f}
Поскольку \f(C\f) по определению больше нуля, то условием устойчивости для схемы \f(\eqref{eq:nonstat_explicit_transport}\f)
будет выражение
\f{equation*}{
    C \leq 1.
\f}

### Метод Неймана

Запишем обратное преобразование Фурье для функции u(x):
\f{equation*}{
    u(x) = \int v(\kappa) e^{\imi \kappa x} \, d\kappa,
\f}
\f(\kappa\f) -- волновое число, \f(\imi\f) -- мнимая единица, \f(v(\kappa)\f) -- Фурье образ исходной функции.

Зададим такое начальное возмущение, которое имеет единичную амплитуду 
на одной частоте, соответствующей волновому числу \f(\kappa_0\f):
\f{equation*}{
    v(\kappa) = \delta(\kappa - \kappa_0),
\f}
\f(\delta(x)\f) -- функция Дирака.
Кроме того, учтём, что \f(x_i = ih\f).
Тогда выбранное начальное возмущение на одной выбранной частоте, взятое в \f(i\f)-ом узле, примет вид
\f{equation}{
    \label{eq:nonstat_neumann_decomp}
    u_i = e^{\imi i \theta}, \quad \theta = \kappa_0 h
\f}
На следующем временном шаге это возмущение примет вид:
\f{equation}{
    \label{eq:nonstat_neumann_decomp_hat}
    \hat u_i = G e^{\imi i \theta}.
\f}
\f(G\f) -- коэффициент усиления. Он показывает во сколько раз
увеличилась амплитуда выбранного возмущения за один шаг по времени.
Для того, чтобы все возмущения затухали, необходимо
\f{equation*}{
    |G| \leq 1, \quad \forall \theta
\f}

#### Неявная противопотоковая схема для уравнения переноса {#NonstatImpConv}

Для примера анализа устойчивости методом Неймана опять рассмотрим задачу \f(\eqref{eq:nonstat_transport}\f),
но на этот раз рассмотрим чисто неявную аппроксимацию
\f{equation}{
    \label{eq:nonstat_implicit_transport}
    \hat u_i + C \left(\hat u_i - \hat u_{i-1}\right) = u_i.
\f}

Подставим \f(\eqref{eq:nonstat_neumann_decomp}\f), \f(\eqref{eq:nonstat_neumann_decomp_hat}\f)
\f{equation*}{
    G e(i) + C \left(G e(i) - G e(i-1)\right)= e(i). 
\f}
где для краткости введено обозначение
\f{equation*}{
    e(i) = e^{\imi \theta i}.
\f}
Поделим на \f(e(i)\f) с использованием свойств этой степенной функции. Тогда

\f{align*}{
    & G + C G \left(1 - e(-1)\right)= 1 \quad \hence \\[10pt]
    & G = (1 + C (1 - e(-1)))^{-1}.
\f}
По определению комплексной экспоненты имеем
\f{equation*}{
    e(-1) = \cos \theta - \imi \sin\theta.
\f}
Требуется показать, что \f(|G| \leq 1\f). Отсюда
\f{align*}{
    & |1 + C (1 - \cos\theta + \imi\sin\theta)|  \geq 1 \quad \hence \\[10pt]
    & |1 + C (1 - \cos\theta) + C\imi\sin\theta)|^2 \geq 1 \quad \hence \\[10pt]
    & 1 + C^2(1-\cos\theta)^2 + 2C(1-\cos\theta) + C^2\sin^2\theta \geq 1 \quad \hence \\[10pt]
    & C^2(1-\cos\theta) + 2C + C^2(1+\cos\theta) \geq 0 \quad \hence \\[10pt]
    & C^2 + 2C \geq 0.
\f}
По определению число Куранта больше 0, поэтому последнее выражение выполняется всегда.
Отсюда следует вывод, что неявная разностная схема вида \f(\eqref{eq:nonstat_implicit_transport}\f)
безусловно устойчива.

#### Противопотоковая схема Кранка-Николсон для уравнения переноса {#NonstatCNConv}

Для того же самого уравнения \f(\eqref{eq:nonstat_transport}\f)
рассмотрим схему Кранка-Николсон \f(\eqref{eq:nonstat_cn_appr}\f):
\f{equation}{
    \label{eq:nonstat_cn_transport}
    \hat u_i + \frac{C}{2} \left(\hat u_i - \hat u_{i-1}\right) = u_i - \frac{C}{2} \left(u_i - u_{i-1}\right).
\f}
Так же
подставим \f(\eqref{eq:nonstat_neumann_decomp}\f), \f(\eqref{eq:nonstat_neumann_decomp_hat}\f)
и поделим на \f(e(i)\f):
\f{align*}{
    & G + \frac{C G}{2} \left(1 - e(-1)\right) = 1 - \frac{C}{2} \left(1 - e(-1)\right) \quad \hence \\[10pt]
    & G = \frac{1 - p}{1 + p}, \quad p = \frac{C}{2} \left(1 - e(-1)\right).
\f}
Для выполнения условия устойчивости \f(|G| \leq 1\f), необходимо
\f{align*}{
    & |1-p|^2 \leq |1+p|^2 \quad \hence \\[10pt]
    & (1 - \Re(p))^2 + \Im(p)^2 \leq (1+\Re(p))^2 + \Im(p)^2  \quad \hence \\[10pt]
    & \Re(p) \geq 0
\f}
Здесь \f(\Re(p)\f), \f(\Im(p)\f) -- дейсвительная и мнимая часть комплексного числа.

Поскольку число Куранта больше нуля, то и действительная часть выражения \f(p\f) неотрицательная для любого \f(\theta\f).
\f{equation*}{
    \Re(p) = \frac{C}{2} \left(1 - \cos\theta\right) \geq 0.
\f}
Получаем, что схема видеа \f(\eqref{eq:nonstat_cn_transport}\f) безусловно устойчива.

#### Явная схема для уравнения нестационарной конвекции-диффузии {#NonstatExpConvDiff}

Рассмотрим уравнение конвекции-диффузии
\f{equation}{
    \label{eq:nonstat_convdiff}
    \dfr{u}{t} + V\dfr{u}{x} = k\dfrq{u}{x}
\f}

Сначала напишем чисто явную схему второго порядка по пространству:
\f{equation}{
    \label{eq:nonstat_convdiff_explicit}
    \frac{\hat u_i - u_i}{\tau} + V\frac{u_{i+1} - u_{i-1}}{2h} = k\frac{u_{i+1} - 2 u_{i} + u_{i-1}}{h^2}
\f}
Введем число Куранта \f(C = V \tau/h\f) и параметр \f(\gamma = k \tau / h^2\f). Тогда

\f{equation*}{
    \hat u_i = \left(\gamma - \frac{C}{2}\right) u_{i+1} + \left(\gamma + \frac{C}{2}\right) u_{i-1} + (1 - 2\gamma) u_i.
\f}
Далее подставим \f(\eqref{eq:nonstat_neumann_decomp}\f), \f(\eqref{eq:nonstat_neumann_decomp_hat}\f)
\f{equation*}{
    G e(i) = \left(\gamma - \frac{C}{2}\right) e(i+1) + \left(\gamma + \frac{C}{2}\right) e(i-1) + (1 - 2\gamma) e(i).
\f}
Поделим на \f(e(i)\f) с использованием свойств этой степенной функции. Тогда
\f{equation*}{
    G = \gamma(e(1) + e(-1)) - \frac {C}{2} (e(1) - e(-1)) + (1 - 2\gamma)
\f}
По определению комплексной экспоненты имеем
\f{align*}{
    e(1) &= \cos \theta + \imi \sin\theta,\\
    e(-1) &= \cos \theta - \imi \sin\theta,
\f}
Отсюда
\f{equation*}{
    G = 2\gamma\cos\theta - \imi {C} \sin\theta + (1 - 2\gamma)
\f}
Запишем квадрат модуля комплексного числа \f(G\f):
\f{align*}{
    |G|^2 = & \left(1 - 2\gamma(1-\cos\theta)\right)^2 + C^2 \sin^2\theta =\\
            & 1 + 4 \gamma^2(1-\cos\theta)^2 - 4\gamma(1-\cos\theta) + C^2 (1 - \cos^2\theta).
\f}

Требование \f(|G| \leq 1\f) эквивалентно \f(|G|^2 \leq 1\f), или
\f{align*}{
    &1 + 4 \gamma^2(1-\cos\theta)^2 - 4\gamma(1-\cos\theta) + C^2 (1 - \cos^2\theta) \leq 1 \quad \hence \\[5pt]
    &4 \gamma^2(1-\cos\theta)^2 - 4\gamma(1-\cos\theta) + C^2 (1 - \cos^2\theta) \leq 0 \quad \hence \\[5pt]
    &4 \gamma^2(1-\cos\theta) - 4\gamma + C^2 (1 + \cos\theta) \leq 0 \quad \hence \\[5pt]
    &(C^2 - 4 \gamma^2) \cos\theta +4\gamma^2 - 4\gamma + C^2 \leq 0
\f}

Поскольку неравенство должно выполняться для всех \f(\theta\f),
а полученное выражение линейно зависит от \f(\cos\theta\f), то будет достаточно рассмотреть два экстремальных значения косинуса,
из которых окончательно запишем два условия устойчивости для явной дискретизации уравнения конвекции-диффузии вида \f(\eqref{eq:nonstat_convdiff_explicit}\f):
\f{equation}{
    \label{eq:nonstat_convdiff_explicit_cond}
    \begin{array}{lcl}
        \cos\theta = 1  & \hence & C \leq \sqrt{2\gamma}, \\
        \cos\theta = -1 & \hence & \gamma \leq 1/2.
    \end{array}
\f}

Обычно вместо первого из условий \f(\eqref{eq:nonstat_convdiff_explicit_cond}\f) применяют
более жёсткое (в случае \f(2\gamma < 1\f)) условие
\f{equation*}{
    C \leq 2\gamma,
\f}
которое с учётом определений сводится к условию на шаг по пространству, формулируемому в терминах сеточного числа Рейнольдса \f(\Ren_c\f):
\f{equation*}{
    \frac{V h}{k} \equiv \Ren_c \leq 2.
\f}

#### Неявная схема для уравнения нестационарной конвекции-диффузии {#NonstatImpConvDiff}

Аналогичным образом рассмотрим неявную диффузии схему для уравнения \f(\eqref{eq:nonstat_convdiff}\f) вида
\f{equation}{
    \label{eq:nonstat_convdiff_semi_implicit}
    \frac{ \hat u_i - u_i}{\tau} + V\frac{ u_{i+1} - u_{i-1}}{2h} = k\frac{\hat u_{i+1} - 2 \hat u_{i} + \hat u_{i-1}}{h^2}
\f}

Подставляя представление для возмущения с волновым числом \f(\theta\f), получим
\f{equation*}{
    G = \frac{1 - \imi C \sin\theta}{1 - 2\gamma(\cos\theta - 1)}
\f}

Для устойчивости необходимо
\f{align*}{
    & |1 - \imi C \sin\theta|^2 \leq |1 - 2\gamma(\cos\theta - 1)|^2 \quad \hence \\[10pt]
    & 1 + C^2\sin^2\theta \leq 1 + 4\gamma^2(1 - \cos\theta)^2 + 4\gamma(1-\cos\theta) \quad \hence \\[10pt]
    & C^2(1 + \cos\theta) \leq 4\gamma^2(1 - \cos\theta) + 4\gamma \quad \hence \\[10pt]
    & \cos\theta(C^2 + 4\gamma^2) + C^2 - 4\gamma - 4\gamma^2 \leq 0
\f}
Наибольшего значения выражение слева достигает при \f(\theta = 0\f). Тогда единственное условие устойчивости 
примет вид
\f{equation*}{
    C \leq \sqrt{2\gamma}.
\f}

### Общие рекомендации к выбору устойчивых расчётных схем
Теоретический анализ условий устойчивости возможен
лишь для простейших уравнений с постоянными шагами дискретизации.
В практических приложениях, имеющих дело, как правило,
с неструктурированными сетками и сложными нелинейными системами уравнений,
параметры устойчивого счёта приходится определять эмпирически.
Однако, такой теоретический анализ позволяет выделить принципы, которыми
следует руководствоваться для построения устойчивых схем.

  1. <U>Неявные схемы более устойчивы, чем явные</U>.
     - Это можно видеть, сравнив результаты анализа
       для безусловно устойчивой \ref NonstatImpDiff "неявной схемы" для уравнения диффузного переноса и
       для условно устойчивой \ref NonstatExpDiff "явной схемы".

     - Для уравнения переноса с разностью против потока
       \ref NonstatExpTran "явная" схема условно устойчива, в то время как
       \ref NonstatImpConv "неявная" -- устойчива безусловно.

     - Даже если только часть схемы неявная, это повышает устойчивость.
       Так, \ref NonstatExpConvDiff "явная" схема для уравнения конвекции-диффузии
       имеет два условия устойчивости, в то время как
       схема, \ref NonstatImpConvDiff "неявная по диффузии" -- только одно.

     - Аналогично, \ref NonstatExpTran "явная" схема против потока для
       уравнения переноса условно устойчива,
       а \ref NonstatCNConv "схема Кранка-Николсон" для того же уравнения устойчива при любых параметрах.

  2. <U>Конвективное слагаемое провоцирует неусточивость, а диффузионное -- напротив, добавляет устойчивость</U>.
     - Так, схемы с центральными разностями для уравнения конвекции-диффузии (и \ref NonstatExpConvDiff "явная", и \ref NonstatImpConvDiff "полунеявная"),
       условно устойчивы. Явная схема с центральными разностями для чистого уравнения переноса всегда неустойчива.
       В последнем можно убедится, подставив \f(k=0\f) в условия устойчивости для уравнений конвекции-диффузии.


## Программная реализация схемы для уравнения переноса 

### Постановка задачи
Рассматриваются три схемы по времени для противопотоковой аппроксимации уравнения переноса \f(\eqref{eq:nonstat_transport}\f): 
- явная схема \f(\eqref{eq:nonstat_explicit_transport}\f) (тест называется `[transport1-explicit]`),
- неявная схема \f(\eqref{eq:nonstat_implicit_transport}\f) (`[transport1-implicit]`),
- схема Кранка--Николсон \f(\eqref{eq:nonstat_cn_transport}\f) (`[tranport1-cn]`).

Уравнение решается на отрезке \f(x\in[0, 1]\f) с единичной скоростью \f(V = 1\f) 
на сетке из 1000 ячеек. Временные итерации продолжаются до момента времени \f(t = 0.5\f).

Начальным условием является функция вида
\f{equation*}{
    u(x, 0) = e^{-x^2/\sigma^2}, \quad \sigma = 0.1
\f}
Точное решение уравнения, с которого будут сниматься граничные условия и производится сравнения полученного численного решения,
запишется как
\f{equation*}{
    u(x, t) = u(x - t, 0) = e^{-(x-t)^2/\sigma^2}.
\f}

На каждом шаге по времени функция сохраняется в vtk-формате.
В конце выводится значение отклонения от точного решения на конечный момент времени.

В качестве цели решения обозначим построение решения и визуальное сравнение решений
при числе \f(C=0.9\f) по трём разным схемам.
А также построение графика сходимости отклонения точного решения
от численного при изменении числа Куранта и фиксированном шаге по пространству
(то есть сходимость при уменьшении шага по времени).

Программы реализованы в файле `transport_solve_test.cpp`.

### Функция верхнего уровня
\dontinclude{lineno} transport_solve_test.cpp

Для всех трёх программ функция верхнего уровня имеет один и тот же вид.
Рассмотрим на примере первой из них:
\skip "[transport1-explicit]"
\until TEST_CASE

Вначале происходит установка параметров численной схемы:
- конечного момента времени
- скорости переноса
- длины расчётной области
- разбиения по пространству
- числа Куранта

\skip const double
\until Cu

Далее вычисляются используемые шаги:
- шаг по пространству (из длины области и разбиения),
- шаг по времени (из шага по пространству и числа Куранта)

\skip double h
\until double tau

Потом устанавливается рабочий класс, в котором будет производится решение
\skip TestTransport1WorkerExplicit worker(n_cells)
\until n_cells

Конструируется класс, используемый для связного сохранения
полей на разные моменты времени.
Этот класс создаёт файл `transport1-explicit.vtk.series`
со списком всех сохранённых полей и отнесёнными к ним моментами времени,
который можно впоследствии открыть в Paraview и использовать
функции анимации для воспроизведения поведения решения во времени.
\skip VtkUtils::TimeDependentWriter writer("transport1-explicit");
\until writer
Далее нужно в этот класс сохранить решение на начальный момент времени.
Для этого туда сначала добавляется запись о нулевом моменте времени
\skip out_filename
\until out_filename
В переменную `out_filename` записывается конкретное
имя vtk-файла, куда следует сохранить решение.
Уже это имя используется для сохранения решения на текущий (начальный) момент времени.
\skip out_filename
\until out_filename

Далее начинается цикл по времени,
продолжающийся до тех пор, пока внутреннее время решателя
не достигнет конечного
\skip while
\until while

Внутри вызывается функция решения, которая продвигает
внутреннее время решателя на \f(\tau\f), обновляет
актуальное состояние вектора решения
и возвращает текущую норму.
\skip norm
\until norm

Потом повторяется процедура сохранения
текущего состояния решателя
\skip out_filename
\until save_vtk

После завершения цикла в консоль печатается
установленное разбиение по времени и
полученное отклонение от точного решения
на конечный момент времени 
\skip cout
\until cout

### Расчётные функции

Три класса-решателя для трёх заявленных задач:
`TestTransport1WorkerExplicit`,
`TestTransport1WorkerImplicit`,
`TestTransport1WorkerCN`
наследуются от одного абстрактного класса
`ATestTransport1Worker`. В этом
абстрактном классе реализованы
все общие для всех решателей функции:
создание сетки, сохранение в vtk,
расчёт нормы, продвижение по времени.

Этот класс также хранит в себе параметры, полностью определяющие текущее состояние решения:
- расчётную сетку,
- шаг по времени (это параметр, производный от сетки, он сохранён в отдельное поле для удобства расчётов),
- вектор решения на текущий момент,
- текущее время.

Эти поля хранятся в `protected` секции, таким образом
все производные классы имеют к этим полям полный доступ.
\dontinclude{lineno} transport_solve_test.cpp
\skip protected:
\until _time

Функция решения, также реализована в абстрактном классе.
Она продвигает текущее время и вызывает
виртуальный метод `impl_step`, который
изменяет значение вектора решения, а в конце вызывает
функцию вычисления ошибки.
\dontinclude{lineno} transport_solve_test.cpp
\skip double step
\until }

Функция `impl_step` уже зависит от конкретной схемы и реализована в
производных классах

#### Явная схема

\dontinclude{lineno} transport_solve_test.cpp

Её решатель реализован в классе `TestTransport1WorkerExplicit`. Рабочая функция по порядку:
- копирует текущий вектор значений во вспомогательный вектор `u_old`.
  Этот шаг добавлен сюда для ясности. Вообще говоря, его можно было избежать.
- устанавливает граничное условие в левой точке
- далее в цикле по точкам реализует расчётную схему \f(\eqref{eq:nonstat_explicit_transport}\f).

\skip TestTransport1WorkerExplicit
\skip impl_step
\until }
\until }


#### Неявная схема
Её решатель реализован в классе `TestTransport1WorkerImplicit`.
Поскольку здесь для нахождения решения требуется решить СЛАУ, то
порядок действий включает в себя:
- формирование класса-решателя.
- формирование столбца свободных членов
- вызова функции решения СЛАУ для найденного столбца правой части. Ответ записывается
  во внутреннее поле класса `_u`

\skip TestTransport1WorkerImplicit
\skip impl_step
\until }

Для построения и инициализации решателя необходимо
собрать матрицу правой части системы уравнений \f(\eqref{eq:nonstat_implicit_transport}\f).
Матрица зависит от шага по времени (через число Куранта), при этом шаг по времени является
аргументом функции `build_solver`, которая приходит от пользователя решателя через аргумент функции `step()`.

Таким образом, в логике работы приложения, нам придётся пересобирать матрицу на каждой временной итерации.
При этом, почти всегда шаги по времени постоянны для временных слоёв. То есть одну и ту же операцию (сборку матрицы)
при одним и тех же аргументах (шаге по времени) придётся повторять. 

Поскольку сборка матрицы -- дорогая операция, то результат работы
функции `build_solver` мы кэшируем (сохраняем во внутреннее поле класса `_solver`).
С тем чтобы на следующем временном слое в случае, если шаг по времени не изменился (`_last_used_tau == tau`),
просто вернуть ответ, посчитанный ранее.
\skip build_solver
\until return
\until }

Сама сборка двухдиагональной матрицы происходит в функции `build_lhs`.
В первой и последней строке учитываются граничные условия, а строки, соответствующие внутренним узлам,
заполняются согласно схеме \f(\eqref{eq:nonstat_implicit_transport}\f)
\skip build_lhs
\until return
\until }

Сама сборка правой части СЛАУ происходит в функции `build_rhs`.
Согласно схеме \f(\eqref{eq:nonstat_implicit_transport}\f)
правый столбец равен значению функции на предыдущем временном слое.
В коде мы создаём столбец `rhs` как копию вектора `_u`.
А далее переписываем первый и последний элемент с тем, чтобы
учесть граничные условия.
\skip build_rhs
\until return
\until }

#### Схема Кранка-Николсон
Её решатель реализован в классе `TestTransport1WorkerCN`.

По аналогии с предыдущей программой, здесь требуется
решить СЛАУ, возникающую из схемы \f(\eqref{eq:nonstat_cn_transport}\f).
Таким образом, вся логика работы этого класса (включая кэширование решателя) повторяет логику
работы рассмотренного ранее класса для чисто неявной схемы `TestTransport1WorkerImplicit`.
Отличаются эти классы только реализацией функций построения матрицы и
правой части. Поэтому настоящий класс наследуется от `TestTransport1WorkerImplicit`
\skip TestTransport1WorkerCN
\until public

и переопределяет только функции 
сборки левой части \f(\eqref{eq:nonstat_cn_transport}\f) с учётом граничных условий
\skip build_lhs
\until return
\until }

и правой части \f(\eqref{eq:nonstat_cn_transport}\f) с учётом граничных условий
\skip build_rhs
\until return
\until }

### Анализ результатов работы

Сравнение полученных ответов (по явной и неявной схемам) с точным решением представлено на картинке ниже.
\image html transport1_solution.png width=1000

Чтобы получить такую картинку необходимо открыть в
Paraview сгенерированные в результате работы программ
выходные файлы `transport1_explicit.vtk.series` и `transport1_implicit.vtk.series`.
И далее проделать преобразования, описанные в пункте \ref paraview-1d.

Для построения графиков сходимости, необходимо преобразовать
написанные программы, запустив цикл по различным значениям числа Куранта
\code{cpp}
for (double Cu: { ... }){
    // solution
    std::cout << 1/tau << " " << norm << std::endl;
}
\endcode
и построить график полученной таблицы в логарифмических осях.
При задании диапазона изменений \f(C\f) следует учитывать, что явная схема устойчива только при \f(C \leq 1\f),
в то время как две другие схемы безусловно устойчивы.

Графики сходимости с уменьшением шага по времени
представлены ниже
\image html transport1_norms.png width=1000

Видно, что для явной схемы с уменьшением шага по времени
ответ отдаляется от точного, а для неявной -- наоборот, приближается.

Это объясняется тем, что в случае явной схемы
ошибки по времени и по пространству имеют разный знак
и (в случае их равенства) компенсируют друг друга.
А для неявной эти ошибки имеют одинаковый знак.

В пределе (с минимальным шагом по времени) все три схемы
сходятся к одной и той же ошибке (ошибке схемы по пространству).
