@page tasks Задания для самостоятельной работы

# Лекция 1 (02.09)
Собрать проет cfd на своей системе и разобраться с его основными принципами

# Лекция 2 (09.09)
1. Построить график, подтверждающий второй порядок точности
   @ref poisson1d_fdm "расчётной схемы" 
2. Написать тест, аналогичный \ref test_poisson1 "[poisson1]" но
   для двумерной задачи на двумерной регулярной сетке
   \f{equation*}{
       -\left(\dfrq{u}{x} + \dfrq{u}{y}\right) = f(x, y).
   \f}
   Использовать разностную схему
   \f{equation*}{
       \frac{-u_{k[i-1,j]} + 2 u_{k[i, j]} - u_{k[i+1,j]}}{h_x^2} +
       \frac{-u_{k[i,j-1]} + 2 u_{k[i, j]} - u_{k[i,j+1]}}{h_y^2} =
       f_{k[i,j]},
   \f}
   где
   \f{equation}{
        \label{eq:tasks_ij2k}
        k[i, j] = i + (n_x+1) j
   \f}
   -- функция, переводящая парный \f$(i,j)\f$ индекс узла регурярной сетки (\f(i\f) для оси x, \f(j\f) для оси y) в сквозной индекс \f$k\f$
   сеточного вектора, \f$n_x\f$ -- количество ячеек сетки в направлении x.

   При вычислении весов \f(w_k\f) для вычисления среднеквадратичного отклонения учесть
   наличие граничных и угловых точек:
    \f{equation*}{
        w_k = \begin{cases}
                h_x h_y / 4,  &\quad  \text{для угловых точек};\\
                h_x h_y / 2,  &\quad  \text{для граничных неугловых точек};\\
                h_x h_y,      &\quad  \text{для внутренних точек}.
        \end{cases}
    \f}
    Четрые угловые точки определяются как
    \f{equation*}{
        i[k], j[k] = (0, 0), \, (0, n_y), \, (n_x, n_y), \, (n_x, 0)
    \f}
    Граничные неугловые точки:
    \f{equation*}{
        \begin{array}{lll}
            i[k], j[k] =& \overline{1,n_x-1}, 0;    & \text{нижняя сторона},\\
                        & n_x, \overline{1,n_y-1};  & \text{правая сторона},\\
                        & \overline{1, n_x-1}, n_y; & \text{верхняя сторона},\\
                        & 0, \overline{1,n_y-1};    & \text{левая сторона}.
        \end{array}
    \f}
    Функции, переводящие сквозной индекс в пару \f(i,j\f), имеют вид
    \f{equation}{
        \label{eq:tasks_k2ij}
        \begin{array}{ll}
            i[k] = {\rm mod}\left(k, \left(n_x+1\right)\right), & \text{// остаток от деления},\\
            j[k] = \lfloor k / \left(n_x+1\right)\rfloor,       &\text{// целая часть от деления}.\\
        \end{array}
    \f}

    Использовать класс cfd::RegularGrid2D для задания сетки.
    Функции перевода индексов узлов из сквозных в парные и обратно реализованы в классе двумерной регулярной сетки:
    - cfd::RegularGrid2D::to_split_point_index
    - cfd::RegularGrid2D::to_linear_point_index

    В случае, если решатель системы линейных уравнений не решает построенную матрицу, использовать функцию
    cfd::dbg::print для отлаточной печати матрицы в консоль (размерность задачи должна быть небольшой).

# Лекция 3 (16.09)

## Постановка задачи
Написать двумерный решатель для уравнения переноса
\f{equation*}{
    \dfr{u}{t} + U \dfr{u}{x} + V \dfr{u}{y} = 0.
\f}

Решение проводить в квадрате \f(x,y\in[-1,1]\f).

Требуется
- расчитать и нарисовать в Paraview нестационарное решение (см. \ref paraview-2d);
- построить график, иллюстрирующий увеличение нормы ошибки
  с продвижением по времени;
- исследовать устойчивость схемы. Эмпирическим путём выяснить,
  какое максимально возможный шаг по времени можно брать
  при фиксированном разбиении по пространству;
- построить график, иллюстрирующий сходимость нормы
  ошибки при уменьшении шага по времени при фиксированном разбиении
  по пространству.


### Тестовый пример 1
На этапе первичного тестирования использовать
значения скорости
\f{equation*}{
    U = 1, \quad V = 0.
\f}

А в качестве начального решения брать простой "столбик"
\f{equation*}{
    u(x,y,0) = u_0(x, y) = \begin{cases}
        1, & \; -1\leq x \leq -0.8, \; -0.1 \leq y \leq 0.1, \\
        0, & \; \text{иначе}.
    \end{cases}
\f}

\image html transport1_work_01.png width=1000

Точным решением будет функция
\f{equation*}{
    u^e(x, y, t) = u_0(x-t, y)
\f}

То есть этот столбик будет двигаться вправо с единичной
скоростью и за время 2 полностью покинет расчётную область.


### Тестовый пример 2

После того, как этот тест будет пройден,
использовать постановку с непостоянной по пространству скоростью
\f{equation*}{
    U(x, y) = -y, \quad V(x, y) = x.
\f}

и начальным решением вида
\f{align*}{
    &r_0(x, y) = \sqrt{(x - 0.5)^2 + y^2}; \; \sigma = 0.1;\\
    &u(x, y, 0) = u_0(x, y) = e^{-r_0^2(x, y)/\sigma^2}
\f}

\image html transport1_work_02.png width=1000

В процессе решения этот "холмик" будет
двигаться по окружности, описывая полный оборот за время \f(t=4\pi\f).

Точное решение на момент времени \f(t\f) будет иметь вид
\f{align*}{
  	& x_c(t) =  0.5\cos(0.5 t); \\
    & y_c(t) =  0.5\sin(0.5 t); \\
    & r(x, y, t) = \sqrt{(x - x_c(t))^2 + (y - y_c(t))^2};  \\
    & u^e(x, y, t) = e^{-r^2(x, y, t)/\sigma^2}
\f}


## Расчётная схема

Использовать противопотоковую явную схему:
\f{equation*}{
    \frac{\hat u_k - u_k}{\tau}
        + |U_k| \frac{u_k - u_{\upx{k}}}{h_x}
        + |V_k| \frac{u_k - u_{\upy{k}}}{h_y} = 0
\f}

Здесь \f(\upx{k}\f), \f(\upy{k}\f) -- 
значения индексов, расположенных против потока
отностительно узла \f(k\f) в направлениях \f(x\f) и \f(y\f) соответственно.

Поскольку скорость в настоящей постановке непостоянная и зависит от точки пространства,
то вычислять индекс узла, расположенного против потока
приходится в зависимости от значения скорости.
С использованием ранее введёных алгоритмов перехода
от парных \f((i, j)\f) индексов к сквозному индексу \f(k\f) \f(\eqref{eq:tasks_ij2k}\f) и обратно \f(\eqref{eq:tasks_k2ij}\f) запишем
\f{align*}{
    & i = i[k]; \\
    & j = j[k]; \\
    & \upx{k} = \begin{cases}
          k[i-1, j], & \quad U_k \geq 0, \\
          k[i+1, j], & \quad U_k < 0 ,\\
      \end{cases} \\
    & \upy{k} = \begin{cases}
          k[i, j-1], & \quad V_k \geq 0, \\
          k[i, j+1], & \quad V_k < 0.\\
      \end{cases}
\f}

В схеме скорости переноса взяты по абсолютному значению.
Это связано с зависимостью направления конечной разности от знака скорости.
Так если \f(U_k > 0\f), то для дискретизации производной по \f(x\f) используется разность
назад:
\f{equation*}{
    U\dfr{u}{x} \approx U_k\frac{u_{k[i, j]} - u_{k[i-1, j]}}{h_x}
    = |U_k|\frac{u_{k[i, j]} - u_{k[i-1, j]}}{h_x}
    = |U_k|\frac{u_{k[i, j]} - u_\upx{k}}{h_x}
\f}
Если же \f(U_k < 0\f), то используется разность вперёд
\f{equation*}{
    U\dfr{u}{x} \approx U_k\frac{u_{k[i+1, j]} - u_{k[i, j]}}{h_x}
    = -U_k\frac{u_{k[i, j]} - u_{k[i+1, j]}}{h_x} 
    = |U_k|\frac{u_{k[i, j]} - u_{k[i+1, j]}}{h_x} 
    = |U_k|\frac{u_{k[i, j]} - u_\upx{k}}{h_x} 
\f}

На границах использовать условия первого рода. Можно просто нули, поскольку они соответствуют постановке.

# Лекция 4 (30.09)

1. Подобрать оптимальные параметры алгоритма SIMPLE \f(\tau, \alpha_p\f) для задачи в каверне,
   при которых сходимость происходит за наименьшее число итераций.
   Для этого лучше понизить пороговый \f(\eps=0.01\f).
   Сравнить полученные вами эмпирически значения с рекомендованными.
   Увеличить разбиение и отметить, как величина шага по простравнству влияет на количество
   требуемых итераций.
   Для ускорения параметрических расчётов лучше собирать программу в \ref release_build "релизной"
   версии и убрать сохранение в vtk внутри каждой итерации.

2. Нарисовать поле невязок \f(r_u, r_v\f) в динамике. Отметить в каком из уравнений и в каких местах области расчёта
   наблюдаются наибольшие проблемы со сходимостью.

3. Решить аналогичную задачу, в которой скорость не только на верхней, но и на
   нижней стенке равна U=1.
   Для этого завести новый тест `[cavern2-simple-sym]` и новый тестовый
   рабочий класс `Cavern2DSimpleSymWorker`, который
   отнаследовать от существующего класса `Cavern2DSimpleWorker`.
   Для того, чтобы при реализации нового класса не повторять существующий код, а пользоваться механизмом
   перегрузок виртуальных функций, необходимо будет
   произвести небольшой рефакторинг:
   ввести новый приватный метод класса `Cavern2DSimpleWorker`
   @code{cpp}
   virtual double get_bottom_velocity() const;
   @endcode

# Лекция 5 (06.10)

Для расчитанного ранее течения в каверне расчитать скалярные поля функции тока и завихренности.

- Сначала для вычисления завихренности использовать формулы
  \ref omega_scheme_internal "для внутренних"
  и \ref omega_scheme_bc "граничных" узлов.
- Затем полученную завихренность использовать для вычисления \f(\psi\f).
  Для этого необходимо собрать и решить систему линейных уравнений, где внутренним узлам
  будет соответствовать \ref psi_scheme "разностная схема",
  а для граничных -- условие \f(\psi_{i,j} = 0\f). 
- Полученные поля сохранить в vtk, добавив
  строки
  @code{cpp}
  VtkUtils::add_point_data(psi, "psi", filepath);      // найденный сеточный вектор psi
  VtkUtils::add_point_data(omega, "omega", filepath);  // найденный сеточный вектор omega
  @endcode
  в функцию сохрания на основной сетке 
  @code{cpp}
  void Cavern2DSimpleWorker::save_current_fields(size_t iter){
      if (_writer_all){
          ...
  @endcode

# Лекция 6 (13.10)

В SIMPLE-решателе для течения вязкой жидкости в каверне `[cavern2-simple]`
рассмотреть простые итерационные подходы к решению систем уравнений
для \f(u^*\f), \f(v^*\f):
- @ref SLAE-Jacobi "метод Якоби",
- @ref SLAE-Seidel "метод Зейделя",
- @ref SLAE-SOR    "метод SOR."

Реализовать означенные решатели в виде функций вида:
@code{cpp}
// Single Jacobi iteration for mat*u = rhs SLAE. Writes result into u
void jacobi_step(const cfd::CsrMatrix& mat, const std::vector<double>& rhs, std::vector<double>& u){
    ...
};
@endcode
которые делают одну итерацию соответствующего метода без проверок на сходимость.
Аргумент `u` используется как начальное значение искомого сеточного вектора. Туда же пишется 
итоговый результат.

Эти функции необходимо вызывать вместо
@code{cpp}
AmgcMatrixSolver::solve_slae
@endcode
в соответствующих решателях
`Cavern2DSimpleWorker::compute_u_star`,
`Cavern2DSimpleWorker::compute_v_star`.

Если требуется сделать несколько шагов, то вызывать несколько раз подряд.


Все алгоритмы основаны на вычислении выражения вида
\f{equation*}{
   \frac{1}{A_{ii}}\left(r_i - \sum_{j=0}^{j<N} A_{ij}{u_j}\right),
\f}
поэтому рекомендуется выделить отдельную функцию, которая бы вычисляла это выражение
и использовалась всеми тремя решателями
@code{cpp}
double row_diff(size_t irow, const cfd::CsrMatrix& mat, const std::vector<double>& rhs, const std::vector<double>& u){
	const std::vector<size_t>& addr = mat.addr();   // массив адресов
	const std::vector<size_t>& cols = mat.cols();   // массив колонок
	const std::vector<double>& vals = mat.vals();   // массив значений
    ...
}
@endcode

Использовать параметры решателя:
\f{equation*}{
    \Ren = 100, \quad E = 4, \quad n_x = n_y = 50, \quad \eps = 10^{-2}.
\f}

Сделать замеры времени исполнения:
- total - общее время работы итераций SIMPLE,
- assemble - время сборки систем уравнений для \f(u^*\f), \f(v^*\f),
- p-solver - время решения системы для \f(p'\f),
- uv-solvers - время решения систем для \f(u^*\f), \f(v^*\f).

Замеры проводить в Release-версии сборки и с отключенными функциями сохранения в vtk.

Для замера времени исполнения участка кода воспользоваться функциями
- cfd::dbg::Tic  - вызвать до начала участка кода
- cfd::dbg::Toc  - вызвать после окончания участка кода

Так, чтобы замерить время total, нужно обрамить SIMPLE - цикл следующими вызовами
@code{cpp}
// iterations loop
dbg::Tic("total");   // запустить таймер total
size_t it = 0;
for (it=1; it < max_it; ++it){
    double nrm = worker.step();
    ...
}
dbg::Toc("total");  // остановить таймер total
@endcode

Замеры времени p-solver и uv-solver делать в функции `Cavern2DSimpleWorker::step`:
@code{cpp}
dbg::Tic("uv-solvers");
std::vector<double> u_star = compute_u_star();
std::vector<double> v_star = compute_v_star();
dbg::Toc("uv-solvers");
dbg::Tic("p-solver");
std::vector<double> p_stroke = compute_p_stroke(u_star, v_star);
dbg::Toc("p-solver");
@endcode

Замеры времени для сборки левых частей СЛАУ -- в функции `Cavern2DSimpleWorker::set_uvp`:
@code{cpp}
dbg::Tic("assemble");
assemble_u_slae();
assemble_v_slae();
dbg::Toc("assemble");
@endcode

При правильном задании функций замеров, по окончанию работы в консоль должен напечататься отчёт о времени исполнения вида:
@code
     total:  6.670 sec
uv-solvers:  5.220 sec
  assemble:  1.210 sec
  p-solver:  0.181 sec
@endcode

Заполнить таблицу

\f{equation*}{
\begin{array}{l|c|c|c|c|c}
    Метод & \text{Кол-во итераций} & \text{Кол-во итераций} & \text{total, s} & \text{assemble, s} & \text{p solver, s} & \text{uv solvers, s}\\
          & \text{решателя СЛАУ}   & \text{SIMPLE}          & & & & \\
    \hline
    Amg & - &  &  \\
    \hline
    Якоби & 1 &  &  \\
    \hline
    Якоби & 2 &  &  \\
    \hline
    Якоби & 4 &  &  \\
    \hline
    Зейдель & 1 &  &  \\
    \hline
    Зейдель & 2 &  &  \\
    \hline
    Зейдель & 4 &  &  \\
    \hline
    SOR & 1 &  &  \\
\end{array}
\f}
Здесь Amg - исходный решатель.

Сравнить полученное время исполнения со временем, которое занимает исходный метод.
Подобрать оптимальный с точки зрения времени исполнения метод решения СЛАУ и его настройки (количество внутренних итераций).
